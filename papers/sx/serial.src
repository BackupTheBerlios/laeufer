   DEVICE SX52 , OSCXT5 
   ; DEVICE TURBO, STACKX_OPTIONX
  ; DEVICE STACKX_OPTIONX
  ;device SX28L, OSCXT5, TURBO, STACKX_OPTIONX, PROTECT
 
	freq	48_000_000
	;freq	11_059_200
	reset	start
        id 'CHR00152'  
;----------------------------------------------------------
;
; Tool Macros
;
;----------------------------------------------------------


WATCH 	UART_XCH_STATUS,8,UDEC
;WATCH	SER01,1,FSTR
WATCH	SER01,8,UHEX
;WATCH	SER02,1,FSTR
WATCH	SER02,8,UHEX
;WATCH	SER03,1,FSTR
WATCH	SER03,8,UHEX
;WATCH	SER04,1,FSTR
WATCH	SER04,8,UHEX
;WATCH	SER05,1,FSTR
WATCH	SER05,8,UHEX
;WATCH	SER06,1,FSTR
WATCH	SER06,8,UHEX
WATCH	store_base,8,UHEX
WATCH	STORE_FOR_IND,8,UHEX

WATCH	tosend,8,UHEX
WATCH	CTS,1,UBIN
WATCH	STD,1,UBIN
WATCH	sendbit,1,UBIN
WATCH	sending,1,UBIN



MODE_SELECT_TRIS        EQU     $1f
MODE_SELECT_PLP         EQU     $1e
MODE_SELECT_LVL         EQU     $1d
MODE_SELECT_ST          EQU     $1c
MODE_SELECT_WKEN        EQU     $1b
MODE_SELECT_WKED        EQU     $1a

LEDgreen		EQU	RA.6
LEDblue			EQU	RA.7


OUTPUT			EQU	$0A	; Rückgebwerte
RETVAL			EQU	$0B
PARAM1			EQU	$0C
PARAM2			EQU	$0D	; Parameter für unterprogrammaufruf.
STORE_FOR_IND		EQU	$0E	; Zwischnespeicher für die Indireckta Adressierung
UART_XCH_STATUS		EQU	$0F	; Globales Register für den Zustand des Empfangsspeichers der seriellen Schnittstelle


;OPTION REGISTER (%76543210)
;BIT		  meaning
; 7	0= $01 is W , 1= $01 is RTCC
; 6	0= RTCC roll-over enabled 1=disabled
; 5	0= RTCC increment on internal instr. , 1= increm. on pin
; 4	RTCC increment: 0= on low-high transition, 1= high-low transition
; 3	prescaler 0= on ,1 = off
; 2	prescale divide rate
; 1	see manual for further info
; 0


OPTION_ACCRTCC_INT      EQU %10011111	;$01 is RTCC ,interrupt on ,prescaler off , increment on instr.

OPTION_ACCRTCC_NOINT    EQU %11011111	;;$01 is RTCC ,interrupt off ,prescaler off , increment on instr.


; 50 MHZ, 115200 Bd
INT_PERIOD   		EQU 104


;----------------------------------------------------------
;intial values of port registers
;----------------------------------------------------------

PORT_A_VALUE    EQU %0000_0000 ; sets bit on port     
PORT_A_TRIS     EQU %0011_1111 ; configures data direction 1=input 0=output
PORT_A_PLP      EQU %1111_1111 ; pullup resistors config 1=disable 0=enable
PORT_A_LVL      EQU %0000_0000 ; CMOS/TTL selection 1=TTL 0=CMOS

PORT_B_VALUE    EQU %0000_0000 ; sets bit on port     
PORT_B_TRIS     EQU %0111_1111 ; configures data direction 1=input 0=output
PORT_B_PLP      EQU %1111_1111 ; pullup resistors config 1=disable 0=enable
PORT_B_LVL      EQU %0000_0000 ; CMOS/TTL selection 1=TTL 0=CMOS
PORT_B_ST       EQU %1111_1111 ; schmitt trigger 1=disable ST  0=enable ST
PORT_B_WKEN     EQU %1111_1111 ; multi input wakeup 0=enable 1=disable (see p136 in manual)
PORT_B_WKED     EQU %0000_0000 ; wakeup edge detection 1=falling_edge 0=rising_edge

PORT_C_VALUE    EQU %0000_0000 ; sets bit on port  
PORT_C_TRIS     EQU %1011_1111 ; configures data direction 1=input 0=output
PORT_C_PLP      EQU %1111_1111 ; pullup resistors config 1=disable 0=enable
PORT_C_LVL      EQU %0000_0000 ; CMOS/TTL selection 1=TTL 0=CMOS
PORT_C_ST       EQU %1111_1111 ; schmitt trigger 1=disable ST  0=enable ST

PORT_D_VALUE    EQU %0100_0000 ; sets bit on port  
PORT_D_TRIS     EQU %0000_0100 ; configures data direction 1=input 0=output
PORT_D_PLP      EQU %1111_1111 ; pullup resistors config 1=disable 0=enable
PORT_D_LVL      EQU %0000_0000 ; CMOS/TTL selection 1=TTL 0=CMOS
PORT_D_ST       EQU %1111_1111 ; schmitt trigger 1=disable ST  0=enable ST

PORT_E_VALUE    EQU %0000_0000 ; sets bit on port  
PORT_E_TRIS     EQU %0000_0000 ; configures data direction 1=input 0=output
PORT_E_PLP      EQU %1111_1111 ; pullup resistors config 1=disable 0=enable
PORT_E_LVL      EQU %0000_0000 ; CMOS/TTL selection 1=TTL 0=CMOS
PORT_E_ST       EQU %1111_1111 ; schmitt trigger 1=disable ST  0=enable ST






;####################################################################			
; Modules
;####################################################################			

;----------------------------------------------------------
;
; Serielle  Schnittstelle
;
;	Neuimplementierung der seriellen Schnittstelle
;	verwendet werden 5 Kabel
;	TD, RD, CTS, RTS, GND
;	Der Hauptteil des Moduls spielt sich im Interrupt ab
;	hier werden getaktet der Eingang abgetastet und neue Signale gelegt
;	nur fürs senden gibt es einmalig eine unterroutine per call aufzurufen die  	
; 	als parameter das zu sendne Wort bekommt
;	Senden ist also nur byteweise möglich
;----------------------------------------------------------




;--------------------------------------
; Konstanten und Signale
;--------------------------------------

DATA_SEG_SERIAL_READ	MACRO

SERIAL_READ_BANK	= $

	SER01	DS 1
	SER02	DS 1
	SER03	DS 1
	SER04	DS 1
	SER05	DS 1
	SER06	DS 1
	SER07	DS 1
	SER08	DS 1
	SER09	DS 1
	SER0A	DS 1
	SER0B	DS 1
	SER0C	DS 1
	SER0D	DS 1
	SER0E	DS 1
	SER0F	DS 1
	
		ENDM

DATA_SEG_SERIAL_WRITE	MACRO
SERIAL_WRITE_BANK	= $

	SEW01	DS 1
	SEW02	DS 1
	SEW03	DS 1
	SEW04	DS 1
	SEW05	DS 1
	SEW06	DS 1
	SEW07	DS 1
	SEW08	DS 1
	SEW09	DS 1
	SEW0A	DS 1
	SEW0B	DS 1
	SEW0C	DS 1
	SEW0D	DS 1
	SEW0E	DS 1
	SEW0F	DS 1
	
		ENDM


DATA_SEG_GLOBAL_XCHANGE	MACRO

GLO_XCH_BANK	= $

	XI0	DS 1
	XI1	DS 1
	XI2	DS 1
	XI3	DS 1
	XI4	DS 1
	XI5	DS 1
	XI6	DS 1
	XI7	DS 1
	XO0	DS 1
	XO1	DS 1
	XO2	DS 1
	XO3	DS 1
	XO4	DS 1
	XO5	DS 1
	XO6	DS 1
	XO7	DS 1
	
		ENDM

;--------------------------------------
; Daten-Segment
;--------------------------------------

DATA_SEG_serielle		MACRO

serielle_BANK 	=	$

bitcounter	    DS		1
StoredByte	    DS		1
scancounter	    DS		1
serial_FLAGS	    DS		1
store_base	    DS		1	; Pointer auf das erste Register des Kommunikationenspeichers der sereillen
STOPBIT_COUNTER	    DS		1	; der sorgt dafür das nach dem Stopbit noch ein bischen zeit vergeht
Port_reg	    DS		1	; register zum Zwischenspeichern des Ports
; Register für senderoutine
wait_counter	    DS		1	; quasi der scancounter fürs senden (verzögert die änderung des Output um 4 Interrupts)
bitcounter2	    DS		1	; zählt die Bits die gesendet wurden
tosend		    DS		1	; zu sendendes Byte


RTS		EQU		RC.5	; clear to send
SRD		EQU		RB.6	; Receive Data
STD		EQU		RC.6	; Transmit Data Leitung
CTS		EQU		RB.7	; clear to send


JUSTIERT	EQU		serial_FLAGS.1 
MEM_LOCK	EQU		serial_FLAGS.2
receiving_Flag	EQU		serial_FLAGS.3 ; zeigt an ob gerade ein Byte empfangen wird oder nicht
sendbit		EQU		serial_FLAGS.4 ; BIT das in das Outputbit gespiegelt wird
sending		EQU		serial_FLAGS.5 ; Stausbit ob gesendet wird oder nicht

TEST_BIT_AUSGANG	EQU	RD.7 ; nur zum testen .....


				ENDM
;--------------------------------------
;Initsegment
;--------------------------------------

INIT_SEG_serielle	MACRO
BANK	serielle_BANK
IF	serielle_BANK > $7F
	SETB	FSR.7
	ELSE
	CLRB	FSR.7
	ENDIF

;BREAK
MOV	bitcounter, #8
CLR	StoredByte
CLR	scancounter
;MOV	scancounter, #1 ; mit einer Zahl ungleich 0 initialisieren nicht am anfang 
CLR	serial_FLAGS
CLR	STOPBIT_COUNTER


MOV	store_base, #SERIAL_READ_BANK
AND	store_base, #$F0

CLRB	receiving_Flag	; zeigt an ob gerade ein Byte empfangen wird oder nicht (0 kein empfang, 1 empfang)

SETB	CTS	; Ab jetzt kann empfangen werden

			ENDM

;--------------------------------------
;Interrupt-Segment
;--------------------------------------

INTER_SEG_serial	MACRO
	
	;BREAK
	BANK	serielle_BANK
	
	IF	serielle_BANK > $7F
	SETB	FSR.7
	ELSE
	CLRB	FSR.7
	ENDIF

	MOV	Port_reg, RB	;portregister sichern


	; ******************* sendeteil***********************
	SB 	sendbit	; sendebit setzten
	CLRB	STD	; Transmit Data 0
	SNB	sendbit
	SETB	STD	; Transmit Data 1
	
	JNB	sending, absend	 ; wenn wir nicht am senden sind dann raus

	TEST	wait_counter	 ; jeden 4ten Interrupt reingehen
	SZ
	JMP	ending
	MOV	wait_counter, #4 ; wait_counter neu initialisieren
	TEST	bitcounter2	 ; check ob wir schon am end edes Bytes angekommen sind (bitcounter2 = 0)
	JZ	STOPBIT2
	
	;**************************** DEBUG
	CLRB	TEST_BIT_AUSGANG ;zum testen geht das Bit jetzt aus und zu beginn der routine an
	
	XOR	RA, #%1000_0000
	
	RR	tosend		; nächstes Bit setzen
	SC
	CLRB	sendbit
	SNC
	SETB	sendbit
	
	CSNE	bitcounter2, #1	; das hiersorgt dafür das im neunten durchlauf eine eins als stopbit gesetzt wird !!!
	SETB	sendbit
	
	DEC	bitcounter2	; bitcounter decrementieren

	JMP	ending
STOPBIT2
	SETB	sendbit
	CLRB	sending
	;CLRB	CTS		; clear to send abschalten
	
	CLRB	TEST_BIT_AUSGANG ;zum testen geht das Bit jetzt aus und zu beginn der routine an
	
ending
	DEC	wait_counter
absend

	; ******************* empfangsteil***********************
	CSBE	UART_XCH_STATUS, #15	; wenn die 16 empfangregister voll sind (UART_XCH_STATUS=16), dann wird nix empfangen
	JMP	endint
	
	TEST	STOPBIT_COUNTER	; der Stopbitcounter sorgt für ein bischen zeit zwischen den übertragungen 
	JNZ	stopbit		; er zählt quasi das Stopbit aus

	JNB	receiving_FLAG, checkForStart   
	;wir sind am empfangen 
	DEC	scancounter
	; wenn wir in einem 4. Interruptdurchlauf sind, wird ein Bit eingelesen sonst nicht
	JNZ	endint
	
	MOV	scancounter, #4
	DEC	bitcounter
		
	; wenn RD-bit 1 dann 1 im carry, sonst gilt 0 im carry
	; das carrybit wird dann reinrotiert
	CLC
	AND	Port_reg, #%0100_0000
	SZ
	STC
	RR	StoredByte
	
	TEST	bitcounter
	JNZ	endint

	MOV	STORE_FOR_IND, StoredByte		; Byte auf austauschbank legen

	
	MOV	W, store_base	; auf die Adresse der Bank 
	ADD	W, UART_XCH_STATUS	; die Adresse des Registers

	; je nach stand des XCH_STTUS byte wir das gelesene Byte an die höchste oder keine stelle geschrieben	
		
	MOV	FSR,W		; die errechnete adresse ins FSR
	MOV	IND, STORE_FOR_IND ; und das gelesenen Byte per indireckte Adressierung wegschreiben
	INC	UART_XCH_STATUS	; +1 damit kein altes Word überschrieben wird
	BANK	serielle_BANK	; wieder auf die serielle Bank wechseln
	IF	serielle_BANK > $7F
		SETB	FSR.7
		ELSE
		CLRB	FSR.7
		ENDIF

CLRB 	LEDblue
	MOV	STOPBIT_COUNTER, #4
	CLRB	receiving_Flag
	
	;SETB	RTS
	
	JMP	endint
checkForStart
	; hier wird gechecked ob ein startbit gesendet wurde
	JB	SRD, endint ; wenn an RD keine 0 anliegt, dann gehe zu schluss

	CLRB 	LEDgreen
	;CLR	UART_XCH_STATUS ; im Global. Statusreg zeigen, dass Byte jetzt nicht gelesen werden darf!
	MOV	scancounter, #5
	MOV	bitcounter, #8
	SETB	receiving_Flag
	CLR	StoredByte
	;CLRB	RTS
	SKIP	
stopbit	DEC	STOPBIT_COUNTER

	CSBE	UART_XCH_STATUS, #15	; wenn die 16 empfangregister voll sind (UART_XCH_STATUS=16)
	CLRB	RTS			; dann wir RTS auf null gestellt

endint


			ENDM
			
			
;--------------------------------------
;Code-Segment
;--------------------------------------

CODE_SEG_serielle	MACRO

_sendbyte

	SETB	TEST_BIT_AUSGANG	; zum testen geht das jetzt an....

	BANK	serielle_BANK
	IF	serielle_BANK > $7F
	SETB	FSR.7
	ELSE
	CLRB	FSR.7
	ENDIF

	; ich gehe einfach davon aus das RTS an ist

	JB	sending, occupied 	; wenn gerade mit senden beschäftigt, dann gehe raus
	SETB	CTS			; wenn wir senden wollen, dann muss auch CTS an sein (anounce host i am ready to receive = yoe are clear to send)
	CLRB	sendbit 		; Startbit setzen !!!
	
	MOV	tosend, PARAM1
	MOV	wait_counter, #3
	MOV	bitcounter2, #9
	SETB	sending
	
	
	
	occupied
	
	RETP	; rücksprung aus routine


;*********************************************************************
;	sendstatus:
;	liefert in OUTPUT1 eine '0' wenn wir gerade mit senden beschäftigt sind
;	sonst eine 1
	
_sendstatus

	BANK	serielle_BANK
	IF	serielle_BANK > $7F
	SETB	FSR.7
	ELSE
	CLRB	FSR.7
	ENDIF
	
	CLR	RETVAL
	SB	sending
	INC	RETVAL

	RETP
			ENDM

;--------------------------------------
; Call-Segment
;--------------------------------------

CALL_SEG_serielle	MACRO

UART_sendbyte
	JMP	_sendbyte
	
	
UART_sendstatus
	JMP	_sendstatus

			ENDM

;####################################################################			
;####################################################################			
;####################################################################			






;##########################################################
; Konstanten
;##########################################################


;##########################################################
; RAM
;##########################################################

;-------------------------
; --- Common variables ---
;-------------------------

                        ; org $08

;-------------------------
; --- Bank 0 Variablen ---
;-------------------------
                        ; org $10

			
;-------------------------
; --- Bank 1 Variablen ---
;-------------------------
                        ; org $30
   
			
;-------------------------
; --- Bank 2 Variablen ---
;-------------------------
                         org $50
                         
DATA_SEG_SERIAL_READ

			
;-------------------------
; --- Bank 3 Variablen ---
;-------------------------
                         org $70
                         
                         
DATA_SEG_serielle


;-------------------------
; --- Bank 4 Variablen ---
;-------------------------
                        ; org $90
                        
                        
;-------------------------
; --- Bank 5 Variablen ---
;-------------------------
                        ; org $B0
                        
                        
;-------------------------
; --- Bank 6 Variablen ---
;-------------------------
                       
                        
;-------------------------
; --- Bank 7 Variablen ---
;-------------------------


;##########################################################
; Def-Segmente
;##########################################################


;##########################################################
; Code
;##########################################################


;--------------------------------------
; Interrupt Einsprung
;--------------------------------------
	ORG $0

	INTER_SEG_serial	

	MOV W, #-INT_PERIOD	; frequenz von 115 Baud
	RETIW


start		JMP		@main

;--------------------------------------
; MODULE
;--------------------------------------

	ORG $200

	CALL_SEG_serielle

	CODE_SEG_serielle


;--------------------------------------
;Initialisierung
;--------------------------------------

	ORG $400
main
	;initialisierung

		MOV !OPTION, #OPTION_ACCRTCC_NOINT ;Interrupt ausschalten
		
					
		; I/O-Konfiguration initialisieren
		
                MOV RA, #PORT_A_VALUE
                MOV RB, #PORT_B_VALUE
                MOV RC, #PORT_C_VALUE
                MOV RD, #PORT_D_VALUE
                MOV RE, #PORT_E_VALUE
                
                MOV W, #MODE_SELECT_TRIS
                MOV M, W
                MOV !RA, #PORT_A_TRIS
                MOV !RB, #PORT_B_TRIS
                MOV !RC, #PORT_C_TRIS
                MOV !RD, #PORT_D_TRIS
                MOV !RE, #PORT_E_TRIS

                MOV W,   #MODE_SELECT_PLP
                MOV M, W
                
                MOV !RA, #PORT_A_PLP                
                MOV !RB, #PORT_B_PLP
                MOV !RC, #PORT_C_PLP
                MOV !RD, #PORT_D_PLP
                MOV !RE, #PORT_E_PLP
                

                MOV W, #MODE_SELECT_LVL
                MOV M, W                       
                MOV !RA, #PORT_A_LVL         
                MOV !RB, #PORT_B_LVL
                MOV !RC, #PORT_B_LVL
                MOV !RD, #PORT_C_LVL
		MOV !RE, #PORT_D_LVL
                

                MOV W, #MODE_SELECT_ST
                MOV M, W                       
                MOV !RB, #PORT_B_ST
                MOV !RC, #PORT_C_ST
		MOV !RD, #PORT_D_ST
                MOV !RE, #PORT_E_ST
                                       

                MOV W, #MODE_SELECT_WKEN
                MOV M, W                       
                MOV !RB, #PORT_B_WKEN

                MOV W, #MODE_SELECT_WKED
                MOV M, W                       
                MOV !RB, #PORT_B_WKED

                CLR !WDT
                
                CLR UART_XCH_STATUS
                
                SETB LEDgreen  ; green
                SETB LEDblue  ; blue
                
		; interrupt aktivieren
                MOV !OPTION, #OPTION_ACCRTCC_INT  ;interrupt wieder anschalten

		INIT_SEG_serielle

;--------------------------------------
;--------------------------------------
; Hauptprogramm
;--------------------------------------
;--------------------------------------


; #$41 ist A #$42 ist B

 mainloop
		; wenn 0 dann ist das Byte nicht lesbar
	
		BANK	SERIAL_READ_BANK
	IF	SERIAL_READ_BANK > $7F
		SETB	FSR.7
	ELSE
		CLRB	FSR.7
	ENDIF
	
	

	;TEST	UART_XCH_STATUS
	;JZ	nothinToDo
	
	;CALL	@sendstatus	; liefert '0' in OUTPUT1 wenn belegt
	
	;TEST	OUTPUT1
	;JZ	nothinToDo
	

	
	CJNE UART_XCH_STATUS, #15, nothinToDo
	
	;MOV	W, #SERIAL_READ_BANK
	;ADD	W, UART_XCH_STATUS	; die Adresse des Registers

	; je nach stand des XCH_STTUS byte wir das gelesene Byte an die höchste oder keine stelle geschrieben	
		
	;MOV	FSR,W		; die errechnete adresse ins FSR
	;MOV	PARAM1,IND	; und das gelesenen Byte per indirekte Adressierung wegschreiben
	;DEC	UART_XCH_STATUS	; -1 damit kein Byte doppelt gelesen wird

	MOV	PARAM1, SER01
	
	CALL	@UART_sendbyte
	DEC	UART_XCH_STATUS
	
	nothinToDo
	
	JMP	mainloop
	
	
;Hier muss ich mir noch GEDANKEN über eine Ringspeicher machen...
;
;
;



;--------------------------------------
; Routinen Page 0
;--------------------------------------
