\section{Aufgabenstellung}

Herzstück dieser Arbeit ist die Implementierung einer ,,intelligenten'' 
Platine. Sie stellt die Schnittstelle zwischen dem Kommunikations-Framework,
wie es in den vorangegangenen Kapiteln beschrieben wurde, und den etwaigen
mechanischen und elektromechanischen Applikationen der Ingenieure des Projekts dar.
Um die Inhalte dieser Arbeit zu erläutern gilt es den Begriff des 
mechatronischen Systems zu erklären. 

Als mechatronisches System wird 
gemeinhin ein funktionell und räumlich integriertes mechanisch
elektrisches System bezeichnet, in dem Sensoren Informationen aufnehmen,
Prozessoren diese Informationen auswerten und Aktoren geziehlt genutzt werden,
um z.B. Kräfte oder Bewegungen zu erzeugen, die auf das System und seine 
Umgebung zurückwirken.

Vor diesem diesem Hintergrund steht den Ingenieuren im Projekt mit der Platine
ein Bausatz zur Entwicklung eines mechatronischen Systems zur Verfügung.
Auf der Platine enthalten ist ein Prozessor, Sensoren und Aktoren sowie Anschlüsse
für weitere Sensorik und Aktorik. Abbildung \ref{cr_mecha_system} stellt die Platine
im Kontext eines mechatronischen Systems dar.
Ziel ist es also ein Werkzeig zu erstellen mittels dem es Ingenieuren möglich 
ist, schnell und einfach mechatronische Applikationen zu erstellen und in das 
Gesamtsystem Läufer zu integrieren.

\begin{figure}
  \center
\rotatebox{90}{
  \includegraphics[width=500pt]{Mechatronik_sys.eps}}
  \caption[Grundstruktur mechatronischer Systeme]{Grundstruktur eines mechatronischen Systems im Läufer (nach \cite{Wallaschek})}
  % Wallaschek 1995, VDI-Berichte 1215
  \label{cr_mecha_system}
\end{figure}


\section{Anforderungen an die Peripherieelektronik}
% Allgemeine Erörterung der Gesamtanforderung


Die Mechatronik im Projekt Läufer muß einer Reihe projektspezifischer
Anforderungen standhalten. Was bedeuten also die eingangs
geschilderten Zielsetzungen für die Peripherieelektronik?

Da sich der genaue Funktionsumfang aller mechatronischen Komponenten
für die Zukunft nicht abschätzen läßt und neue Komponenten
jederzeit einfach einzugliedern sein sollen, muß das System leicht
erweiterbar sein. Für Maschinenbauingenieure muß das
System mit vertretbarem Aufwand bedienbar sein. Für den Benutzer
ist der Effekt und nicht der Weg interessant.  Die
begrenzten Ressourcen des autonomen Systems Läufer erfordern
außerdem eine sparsame Nutzung von Energie.  Um die Fahrer nicht durch
Fehlfunktionen oder Ausfall eines Gerätes zu gefährden muß das System
betriebssicher sein. Noch vor der Inbetriebnahme gilt es, die Hardware 
vor Fehlbedienung durch den Ingenieure zu schützen. Das heißt sowohl 
in der physikalischen Auslegung als auch in der Programmierung müssen
mögliche Extreme in der Nutzung des Fahrzeugs berücksichtigt werden.
Bei der Zusammenstellung der Platine muß außerdem die Verfügbarkeit der
Bauelemente sichergestellt sein. Wie in den restlichen Teilen des
Läufers zollen wir auch hier dem Design Tribut: die Platine sollte 
so wenig Raum wie möglich einnehmen, um der Gestaltung des Fahrzeugs 
größtmöglichen Freiraum zu gewähren.

Nicht zuletzt muss auch der Sicherheit Rechnung getragen werden.
Sicherheit in diesem Zusammenhang heißt: Sicherheit vor Strom- 
und Spannungsspitzen zur Betriebszeit und Sicherheit der Komponenten
vor Fehlbedienung durch den Entwickler.


% \subsection{Sicherheit}  % soll raus
% Sicherheit heißt in diesem Zusammenhang: Sicherheit vor Strom- und
% Spannungsspitzen zur Betriebszeit und Sicherheit der Komponenten
% vor Fehlbedienung durch den Entwickler.

% Um von Ausfallsicherheit zur Betriebszeit auszugehen wäre eine groß angelegte Testreihe im Läufer
% mit allen fertigen mechatronischen Applikationen unter verschiedenen Testbedingungen von Nöten.
% Die bisherigen Versuche und Tests außerhalb des Läufers 
% waren erfolgreich.Wie sich die mechatronischen Applikationen der Maschinenbauer im Fall einer Störung verhalten 
% obliegt letztendlich dem jeweiligen Entwickler. Die Relevanz für die Fahrsicherheit kann letztlich erst von ihm abgeschätzt werden.
% Das unten erwähnte Modulmodell für die Software soll dabei unter anderem 
% die Fehleranfälligkeit der Software verringern.

\begin{figure}
  \center
  \includegraphics[width=277pt]{Platine_C-Karte.eps}
  \caption{Grössenvergleich Platine Scheckkarte}
  \label{Platine-Karte}
\end{figure}


\newpage
\section{Die Platine}

%Kommentar zur interdiszipl. Erörterung der Anforderungen
% Überblick über die folgenden themen
% \subsection{Anforderungen an die Platine}
% integrationsdichte
% Sicherheit (Schmelzsicherung)
% \subsection{Realisierung}

Die Platine durchlief zwei Iterationsstufen der Entwicklung. Die
erste, kleinere Platine enthielt noch keinen ausgereiften SPI-Bus\footnote{siehe dazu Kapitel \ref{cr_SPI-Bus}} (der
später erwähnte Multiplexer war noch nicht vorgesehen), die Low-Side
Switches waren nicht integriert und die angeschlossene Peripherie
wurde durch einen kleineren Microcontroller (der SX28) gesteuert.
Der kleinere Microcontroller unterscheidet sich  unter anderem in 
der Anzahl der I/O-Ports, der niedrigeren Taktfrequenz sowie einem
kleineren Arbeits- und Programmspeicher von der aktuell verwendet
Version. Mehr dazu in Kapitel \ref{cr_microcon_chap}.

Die zwei erstellten Prototypen wurden Bald durch eine neue
vierlagige scheckkartengroße Trägerplatine ersetzt. Der zweite
Revision berücksichtigt eine Reihe
weiterer Ideen zur Annäherung an das Ziel einer multifunktionalen
Mechatronikapplikation für Maschinenbauingenieure.  Die
Dimensionierung der passiven Bauelemente erlaubt eine Anpassung an
andere Versorgungsspannungen als die momentanen 12 Volt. Ein
Spannungswandler kann Versorgungsspannungen von bis zu 48 Volt auf die
für CMOS üblichen 5 Volt herunterregeln.  Die Platine entstand in
ständiger Kooperation mit den Maschinenbaustudenten des Projekts und
der Firma Cetron. Um den Anforderungen der Ingenieure gerecht zu werden,
waren immer wieder Erörterungen von möglichen Aufgabenfeldern der 
Platine mit den Maschinenbauern nötig.

Im Folgenden werden einige Aspekte der Platine näher betrachtet.

\subsection{Kosten}  % soll raus
Die Platine enthält Standardbauelemente wie sie zum Teil
auch in der Automobilindustrie verwendet werden. Die Kosten für die
IC's belaufen sich auf ca 58,- Euro (eine genaue
Aufstellung ergibt sich aus Tabelle \ref{cr_ic}). Die passiven
Bauelemente belaufen sich auf ca 20,- Euro (LEDs,
Kondensatoren, Spule, Dioden und Widerstände).  Zusammen mit der
vierlagigen Platte ergibt das einen Preis von ca. 110,-
Euro ohne Bestückungskosten. Das Layout erlaubt jedoch
eine Teilbestückung die sich auf die für ein spezifisches
Peripheriegerät notwendigen Bauelemente beschränkt. Ein weiterer
wichtiger Punkt bei der Kostenbestimmung war die Verwendbarkeit und das
Zusammenspiel der Bauelemente in der gewünschten Zusammenstellung.

Die genauen Kosten der Platine hängen nicht unwesentlich von der Wahl
der Komponentendistributoren ab. Preisunterschiede von bis zu\linebreak 400 \%
(z.B. bei blauen LEDs) sind keine Seltenheit. Eine sorgfältiger
Preisvergleich der möglichen Lieferanten ist wichtiger Bestandteil der
Kostenbestimmung (und letztendlich des Einkaufs) gewesen.

\subsection{Ausfallsicherheit zur Betriebszeit} % soll raus
Komponenten mit Anschlussmöglichkeiten auf der Platine vertragen meist
kurzfristige Strom und Spannungsspitzen und enthalten gegebenenfalls Zener-Dioden.
Näheres dazu steht in der Beschreibung der einzelnen Komponenten in Kapitel \ref{cr_peripherie}.
Die Platien selbst enthält eine besonders dünne Leiterbahn, die, sollte der Entwickler doch einmal eine zu hohe Spannung anlegen, als
Schmelzsicherung dient. So werden die teuren IC's vor Schaden bewahrt.

\subsection{Design} % soll raus
Um sich in das Design des Läufers zu integrieren sind sowohl die
Erweiterbarkeit als auch die simple Größe der Platine von
Wichtigkeit. Die Größe der Platine beträgt ca. $4,5 * 8,6 cm$, hat
also etwa die Größe einer Scheckkarte (siehe Abbildung
\ref{Platine-Karte}).




\section{Wahl der Komponenten}
\subsection{Microcontroller}
\label{cr_microcon_chap}

Der Markt für Microcontroller stellt eine große Auswahl an
verschiedensten Konfigurationen zur Verfügung. Um bei der großen
Auswahl zügig zu einer guten Entscheidung zu kommen gilt es, die Menge
der Kriterien frühzeitig einzuschränken.

Wichtigste Kriterien bei der Auswahl waren dementsprechend: Preis,
Anzahl I/O-Ports, Taktfrequenz (um möglichst viel Freiheit bei
der Entwicklung neuer Peripherie zu haben), Qualität erhältlicher
Entwicklungsumgebungen, Energieverbrauch, Größe des Programm- und
Arbeitsspeichers sowie vorhandene Interrupt-Möglichkeiten.

Um den Preis gering zu halten empfahl sich eine 8-Bit Architektur.  Im
8-Bit Bereich sind Produkte folgender Hersteller näher in Betracht
gezogen worden: Infineon/Siemens (C500-Familie), Motorola
(68HC11, 68HC05, 68HC08), Microchip (PIC16Fx), Ubicom (SX).

% infineon http://www.infineon.com/cgi/ecrm.dll/ecrm/scripts/prod_cat.jsp?oid=-8136
% motorola http://e-www.motorola.com
% Microchip	http://www.microchip.com/

\begin{itemize}
  
\item Infineons SABC500-Familie bietet mit zum Teil integrierten
  RS232-Bauelementen eine reiche Auswahl für
  Kommunikationsanwendungen. Mit bis zu 24MHz sind die
  Mikrocontroller für die vorgesehene
  Anwendungen schnell genug. Der Preis von 9 bis 14 Euro
  pro Mikrocontroller ist vergleichbar hoch. Desweiteren müssen für
  den SABC515 die Programme in externen Speicherbausteinen abgelegt
  werden, die unnötig viel Platz in Anspruch nehmen.
  
\item Die Mikrocontrollerreihen 68HC11, 68HC05, 68HC08 von Motorola wird bereits
  vielfach in der Autoindustrie genutzt. Die CISC-Architektur
  machen die Implementierung von Kommunikationsanwendungen \linebreak
  schwierig, da das auszählen des exakten Timings mit unterschiedlich 
  langen Instruktionen den Aufwand unnötig vergrössert. Motorola gleicht
  dies durch eine reiche Auswahl an
  Modellen mit integrierter Kommunikationslogik aus.  Für die 68HC11Fx
  Familie sind mehrere Entwicklungsumgebungen, und reichlich
  Beispielapplikationen erhältlich. Die betrachteten Mikrocontroller
  wiesen jedoch höchstens einen interruptfähigen Pin auf, um
  Interrupts durch externe Geräte auszulösen. Desweiteren existiert
  kein Stromsparmodus.  Auch die Preise von bis zu 14 Euro
  sprechen gegen den 68HC11x.
  
\item Mikrochip ist in den USA für die PIC-Microcontroller bekannt.
  PIC sind schnelle RISC Microcontroller die sich gut für
  Kommunikationsanwendungen eignen. Für die Läufer-Platine wurde die
  PIC16F87x-Familie unter die Lupe genommen, da sie unter den interruptfähigen
  8-Bit Controllern in der gewünschte Preisklasse liegt (5 - 7 Euro).
  Auch hier ist eine große
  Anzahl an Quellen für die Programmierung sowie eine Auswahl an
  Entwicklungsumgebungen erhältlich. Der PIC16F87x ist mit 14
  interruptfähigen Pins unter seinen Konkurrenten am besten
  ausgestattet. Die sehr dürftige Ausstattung mit Programmspeicher
  schränkt die Eignung für die Mechatronikplatine jedoch wieder ein.
  
\item Mit dem SX52 von Ubicom steht zusätzlich ein 
  PIC-kompatibler Mikrocontroller zur Auswahl. Mit acht interruptfähigen PIN's ist
  der SX52 nicht ganz so gut ausgestattet wie der PIC16F87x, reicht
  aber für die vorgegebenen Zwecke aus. Den Mangel an Programmspeicher
  teilt der SX52 mit vier Kilobyte nicht mit seinem Konkurrenten. Sein
  Preis ist mit ca. 7 Euro besser als der des Motorolas
  und gleichauf mit dem PIC-Controller.  Durch die
  PIC-Kompatibilität stehen auch für den SX52 viele Ressourcen offen.
  Mit bis zu 100 MHz ist der SX52 der schnellste Microcontroller
  seiner Klasse.
  
  Letztendlich ausschlaggebend für die Wahl des SX52, war die
  erhältliche Entwicklungsumgebung der Firma Parallax. Die Software
  ermöglicht eine schrittweise Verfolgung des Programmablaufs, und
  spiegelt dabei die Arbeitsspeicherbelegung auf den Monitor. Näheres dazu im Kapitel
  \ref{Umgebung}.

\end{itemize}


Ein tabellarischer Vergleich der Mikrocontroller findet sich nochmals
in Tabelle \ref{cr_microcontroller}.

\subsubsection{Die erste Wahl im Detail}

Der SX52\cite{SXMan} (52 steht für die Anzahl an Pins) birgt acht Seiten zu 512
12-Bit Worten Programmspeicher für den Programmcode, und 16 Bänke a 16
Register (8-Bit Register) sowie eine Spezialbank zur Konfiguration.  Das
heißt es stehen 8 Kilobyte\footnote{Eine Instruktion benötigt 12 Bit, 
daher gilt für den Programmspeicher das ein Byte 12 Bit hat} für Programmcode und
$2^{8}$ Register zu Laufzeit zur Verfügung.  Für
Unterprogrammaufrufe steht ein Stapel mit einer Tiefe von acht
Einträgen zur Verfügung. Der Programmspeicher entspricht physikalisch
einem Flashrom, sodaß zum Beispiel weiterentwickelte Versionen
auch im nachhinein eingespielt werden können. Diese Möglichkeit
erleichtert auch die Entwicklung insofern, als das Programme nicht erst
in simulierter Umgebung getestet werden müssen, sondern sofort im
Einsatzumfeld erprobt werden können, ohne große Kosten zu verursachen.

Der SX52 hat fünf 8-Bit Ports, die sowohl als Input als auch als Output
nutzbar sind. Es existiert ein Stromsparmodus (Sleep-Mode) der zur
Laufzeit an- und durch externe Quellen wieder abschalbar ist. Der
Mikrocontroller hat eine Interruptfunktion, die ebenfalls zur Laufzeit
aktivier- und deaktivierbar ist. Einer der fünf Ports kann als
Interrupt oder Weck-Port konfiguriert werden. Das heißt ein Signal an
diesem Port löst einen Interrupt aus bzw. ,,weckt'' den
Mikrocontroller aus dem Stromsparmodus.



\begin{table}
  \label{cr_microcontroller}
  \begin{center}
    \begin{tabular}{|c|c|c|c|}
      \hline
      \emph{Microcontroller}        & \emph{SX52}       & \emph{68HCxx\footnote{xx steht hier für 05,08,oder 11}} & \emph{PIC16F87x} \\
      \hline
      \emph{Architektur}        & RISC & CISC & RISC\\
      \hline
      \emph{Arbeitsspeicher (in Bytes)} & 256 & 1000 & 256 \\
      \hline
      \emph{Programmspeicher}           & $4kB$ & $20kB$ & 368 words \\
      \hline
      \emph{Anzahl I/O Pins}        & $5 \times 8$ & $7 \times 8 + 1 \times 8$ {\tiny input only}& $5 \times 8$\\
      \hline
      \emph{Taktfrequenz}       & $50 MHz$ & $4 MHz$ & $20 MHz$\\
      \hline
      \emph{Interrupt intern/extern }     & ja / ja {\tiny8 Pins}& ja / ja {\tiny 1 Pin} & ja / ja {\tiny14 Pins}\\
      \hline
      \emph{Serielle Schnittstelle} & nein & ja & nein \\
      \hline
      \emph{Strom im Sparmodus}     & $1\mu A$ & / & $5\mu A$\\
      \hline
      \emph{ca. Preis}          & 7 Euro& 14 Euro &  7Euro\\
      \hline
    \end{tabular}
  \end{center}
  \caption{Vergleich der drei favorisierten Microcontroller}
\end{table}


\subsection{Peripherie}
\label{cr_peripherie}
Im folgenden werden die genutzten Bauelemente und Funktionalitäten der
Platine beschrieben.

\begin{description}


\item[Kommunikation] Neben dem SPI-Bus zur internen Kommunikation
  stehen eine serielle Schnittstelle nach RS232-Standard und, wie
  bereits im vorangegangenem Kapitel \ref{jameson_kapitel}
  beschrieben, ein CAN-Controller\cite{MCP2510} für die externe Kommunikation zur
  Verfügung.  Die serielle Schnittstelle ist direkt über einen
  Wandlerbaustein (MAX202CSE) mit dem Microcontroller verbunden. Durch
  die Anbindung des RXD- (RXD = Receive Data) und CTS-Signals (CTS =
  Clear To Send) an den interruptfähigen Port des Mikrocontrollers ist
  eine Aktivierung der Platine via serieller Schnittstelle
  möglich.

\item[Digital-Analog-Wandler] Der am SPI-Bus angeschlossene
  Digital-Analog-Wandler LTC1446\cite{LTC1446} von Linear Technology dekodiert eine $2\times12$ Bit lange
  Nachricht und wandelt sie in zwei analoge Signale. Die Ausgabe
  ist eine lineare Funktion des Betrags der binären Eingangszahlen, so daß
  000hex für Null Volt und FFFhex für zwölf Volt stehen.
  
\item[Analog-Digital-Wandler] Der LTC 1594\cite{LTC1594} von Linear Technology
  enthält einen 4-Kanal Multiplexer über den einer von vier Eingängen
  an den Analog-Digital-Wandler geführt werden kann. Der LTC 1594 ist
  ebenso wie der Digital-Analog-Wandler über den SPI-Bus an den
  Microcontroller angeschlossen. Zur Konfiguration werden anfangs
  vier Bit übertragen die zum einen als Aktivierung und zum anderen
  für die Auswahl des Multiplexereingangs dienen.  Wenn ein Eingang
  ausgewählt ist, dann codiert der Analog-Digital-Wandler die
  anliegende Spannung bis maximal 12 Volt in 12 Bit. Die Abtastrate
  beträgt 16,8 kHz.
  
\item[Low-Side-Switch]Mit dem Siemens Smart Octal Low Side Switch TLE
  6230 GP \cite{TLE6230} stehen über den SPI-Bus zwei Acht-Bit Schalter zur
  Verfügung. Vier der Acht Anschlüsse sind PWM\footnote{PWM: Puls Weit
  Modulation oder engl. Pulse Width Modulation}-bar (Mehr über die
  Puls Weit Modulation in Kapitel \ref{cr_puls}). Die notwendigen Signale für
  die PWM gehen direkt vom Mikrocontroller aus (also ohne den Umweg
  über den SPI-Bus).  Der TLE hat einen Kurzschlußschutz integriert.

\item[Serial Peripheral Interface (SPI)]\label{cr_SPI-Bus} Die große
  Anzahl an Bauelementen macht eine sparsame Nutzung der I/O-Ports am
  Mikroprozessor nötig.  Zu diesem Zweck sind der CAN-Bus-Chip, zwei
  Low-Side-Switches, ein Analog-Digital-Wandler und ein
  Digital-Analog-Wandler über ein SPI-Bus-System mit dem
  Mikrocontroller verbunden. Jeder dieser Bausteine hat einen
  Chipselect-Eingang der bei einer logischen Null den jeweiligen
  Baustein aktiviert. Der SPI-Bus wickelt die Kommunikation der
  Komponenten über zwei Leitungen SI (SPI-Input) und SO (SPI-Output)
  seriell ab.  Die Kommunikation läuft immer zwischen einem Master
  (hier der SX52) und dem durch die jeweilige Chip-Select-Leitung
  ausgewählten Baustein ab. Der Master übernimmt auch die Taktung über
  eine separate CLK-Leitung.

In dieser Applikation wird das jeweilige Chip-Select über einen
  Multiplexer\cite{74HC138} gesetzt. Diese Lösung spart nicht nur wertvolle Pins am
  Port des Mikrocontroller, sie garantiert auch, das nur genau ein Gerät
  auf den Datentransfer reagiert. Dies macht die
  Applikation also ein Stück sicherer.


\item[Brücken] Für verbrauchsstarke Gleichstromgeräte sind zwei
  H-Brücken der Firma Infineon auf der Platine enthalten. Der TLE
  5206-2\cite{TLE5206} kann bis zu 40 Volt Spannung bei fünf Ampere liefern. Er
  verträgt dabei kurzzeitige Stromspitzen von bis zu sechs Ampere.
  Die aus zwei Bausteinen resultierenden vier Anschlüsse, können für vier
  in eine Richtung steuerbare Motoren oder zwei in beide Richtungen
  steuerbare Motoren verwendet werden. Eine weitere Anwendung wäre der 
  Anschluss von Servomotoren.
  
\item[Strommessung an der Brücke]
  Über Jumper läßt sich eine Rückkopplung der Brückenausgänge mit den
  Eingängen des Analog-Digital-Wandlers herstellen.  Der Strom an der
  Brücke wird über einen Widerstand geführt, die abfallende Spannung
  mit einem Operationsverstärker verstärkt und dann im
  Analog-Digital-Wandler gemessen.  Das heißt, es existiert eine
  direkte Möglichkeit zur Messung der Leistungsaufnahme der an der
  Brücke angeschlossenen Verbraucher (z.B. Motoren).
  
\item[Digitale Eingänge] Mit dem ULN2004A gibt es über 7 Anschlüsse
  einen direkten Zugang zum Mikrocontroller.  Der sieben Darlington
  Schaltungen enthaltende Baustein von STMicroelectronics akzeptiert
  eine Eingangsspannung von fünf bis zu acht Volt, je nach
  Eingangsstrom.  Drei der Eingänge werden an den interruptfähigen
  Port des Mikrocontrollers durchgeschaltet. Dadurch ergibt sich eine
  weitere Möglichkeit die Platine von außerhalb zu ,,wecken''.
  
\item[Speicher] Mit dem FM24C64\cite{FM24c} steht ein 64 Kilobyte großer seriell
  bedienbarer Speicher zur Verfügung. Der Speicher ist unterteilt in
  8.192 $\times$ 8 Bits, so daß jeweils acht Bit seriell in den
  Speicher geschrieben werden können. Die Speicherzelle werden also
  mit einer 13-stelligen Binärzahl adressiert ($2^{13} = 8.192 $).
  Der FM24C64 ist über ein sogenanntes ,,Two-wire Interface'' an den
  SX angeschlossen. Dabei generiert der SX als Master das Taktsignal
  für die serielle Übertragung.
  
\item[LED] Um ein optisches Feedback (zum Beispiel für den Fall einer
  Fehlfunktion) für den Programmierer zu ermöglichen, sind zwei
  LEDs\footnote{LED = Light Emitting Diode} an den Mikrocontroller
  angeschlossen. Eine davon ist blau, die andere grün.

\end{description}

%\subsection{Kosten der Peripherie}


\begin{table}
  \caption{Zusammenfassung der verwendeten IC's}
  \label{cr_ic}
  \begin{center}
    \begin{tabular}{|c|c|c|c|}
      \hline
      \emph{Komponente}         & \parbox[]{60pt}{\emph{Hersteller- bezeichnung}}       & \emph{Hersteller} & \emph{ca. Preis in Euro} \\
      \hline
      \emph{Brücken}            & TLE 5206-2 & Infineon & 4.33\\
      \hline
      \emph{Spannungswandler}       & LM2594 & National Semiconductor & 5,09\\
      \hline
      \emph{Operationsverstärker}       & LM324 & National Semiconductor & 0,31 \\
      \hline
      \emph{Darlington Array}           & ULN2004A & STMicroelectronics & 0,66 \\
      \hline
      \emph{Mikrocontroller}        & SX52 & Ubicom & 7 \\
      \hline
      \emph{Low Side Switch}        & TLE 6230 GP & Infineon & 3.79\\
      \hline
      \emph{RS232}                  & Max202CWE & Dallas Semiconductor & 3,26 \\
      \hline
      \emph{CAN-Controller}     & MCP2510 & Microchip & 4.25\\
      \hline
      \emph{Analog-Digital-Wandler} & LTC 1594 & Linear Technology & 11,30 \\
      \hline
      \emph{Digital-Analog-Wandler} & LTC 1446 & Linear Technology &  12,60\\
      \hline
      \emph{Multiplexer}        & MM74HC138 & Fairchild & 0,36 \\
      \hline
    \end{tabular}
    Die Preise sind den Katalogen von RS-Components\cite{RSC},
    Farnell\cite{farnell} und Bürklin\cite{Burk} entnommen.
  \end{center}
\end{table}

\newpage

\section{Anforderungen an die Assemblerprogramme}
Im folgenden werden die Auswirkungen der Vorgaben auf die
Assembler-Programme des Mikrocontrollers beschrieben.

\subsection{Bedienbarkeit}
Was bedeutet Bedienbarkeit im Bezug auf die Programme des
Mikrocontrollers?

Ziel ist es, dem Entwickler eine Art Bibliothek zur Ansteuerung der
einzelnen Platinenkomponenten anzubieten.  Folgende Punkte sind dabei
mit Rücksicht auf die Assemblerumgebung weitest möglich zu beachten:

\begin{itemize}
  
\item Die Programmpakete für die einzelnen Platinenkomponenten müssen
  als Module verfügbar sein, die gegebenenfalls vom Entwickler
  eingebunden werden können. Nicht benötigte Module belegen
  dann keinen Speicherplatz.

\item Die einzelnen Module müssen sich den Arbeitsspeicher so teilen,
  das Keines das jeweils Andere stört bzw. Inkonsistenzen zur Laufzeit
  hervorruft.  Das heißt, daß eine strikte Arbeitsspeichertrennung
  vorhanden sein muß.
  
\item Es müssen Konventionen für den Austausch von Daten zwischen den
  Modulen entwickelt werden.
  
\item Der Programmspeicher muß möglichst effizient von den Modulen
  genutzt werden.
  
\item Innerhalb der Module sollte es keine weiten Verzweigungen durch
  Unterprogrammaufrufe geben, um dem Entwickler (und damit dem Nutzer
  der Module) möglichst viel Freiraum auf dem Unterprogramm-Stapel zu
  gewähren. Der Unterprogrammstapel hält maximal acht Einträge.
  
\item Konstante Einstellungen die sich aus der Architektur der Platine
  ergeben sollten dem Entwickler durch ,,sprechende'' Konstantennamen
  einfach handhabbar gemacht werden.
\end{itemize}

\subsection{Sicherheit}
Bei der Softwareentwicklung der Platinen müssen eventuelle Fehlfunktionen
berücksichtigt und adäquat behandelt werden, ohne die Kommunikationsebene zu
stören.  Desweiteren muß es einen sicheren Zustand geben in den die
Platine bei etwaiger Fehlfunktion versetzt wird um Kurzschluß,
unnötigem Leistungsverbrauch oder ähnlichem vorzubeugen.

\subsection{Kommunikation}

Die Modularität des Systems bringt eine Vielzahl von
Kommunikationsanforderungen mit sich. So müssen die Einzelnen Platinen
in Kontakt mit der Steuereinheit treten. Auf der Platine muß der
reibungslose Austausch zwischen den Programmmodulen sichergestellt
sein, ohne Inkonsistenzen hervorzurufen. Auf Hardwareebene werden
einzelne Komponenten über ein serielles Protokoll angesprochen (SPI).
Und nicht zuletzt muß der Mikrocontroller die zeitkritische serielle
Schnittstelle betreiben (sofern das Modul eingebunden ist).

\subsection{Erweiterbarkeit}
Um auch zukünftige Weiterentwicklungen der Peripherie berücksichtigen
zu können, muß die Programmierung der Komponenten einer klaren
Konvention folgen. So können auch neue Implementierungen diesem Muster
folgen und der Entwickler hat eine geringe Einarbeitungszeit. Eine
Schnittstelle im Sinne einer Hochsprache ist hier nicht von Nöten (und
auch schwer realisierbar), da die geringe Stapeltiefe und der begrenzte
Programmspeicher ohnehin eine geringere Verschachtelungstiefe der
Unterprogramme erzwingen.

\newpage
\section{Konzeption}
\label{Konzeption}
\subsection{Entwicklungsumgebung}
\label{Umgebung}

Wie bereits oben beschrieben war einer der Gründe für die Wahl des
SX52 seine gute Handhabbarkeit bei der Entwicklung. Dies hängt mit der
erhältlichen Entwicklungsumgebung\cite{SXDev} der Firma Parallax zusammen.  Die
Entwicklungsumgebung besteht aus der SX-Software (SX.exe) und dem
SX-Key (siehe Abbildung \ref{cr_sx_key}).

Mit Hilfe des SX-Key spielt man die Software in den Programmspeicher
des SX52 ein.  Er stellt außerdem, im entsprechenden Modus betrieben,
die Debugfunktionen für die SX-Software bereit (Spiegeln und Ändern
der Register und Zähler, sowie externe Taktung). Der SX-Key ist über
die serielle Schnittstelle an den PC angeschlossen. Der Anschluß an
den Mikrocontroller erfolgt über eigens dafür vorgesehene Anschlußpins
auf der Platine.

\begin{figure}
  \center
  \includegraphics[width=277pt]{sx-key_m.eps}
  \caption{Der SX-Key}
  \label{cr_sx_key}
\end{figure}

Die SX.exe stellt sich nach dem Start als Editor dar.  Der
Assembler-Interpreter und die Debugfunktionen lassen sich über einen
Menüpunkt in der Kopfleiste ausführen.

Die Debugfunktion ermöglicht es, die Ausführung von Programmen
schrittweise zu verfolgen und dabei die Registerinhalte zu überwachen.
Desweiteren können bestimmte Register oder gar Bits formatiert (als
binäre, hexadezimale oder dezimale Zahl in einem zusätzlichen Fenster)
angezeigt werden (Abbildung \ref{cr_watchregs}) . Bei jeder Änderung
durch einen Befehl werden die betroffenen Register rot umrandet. Auf
diese Art läßt sich schnell feststellen, ob das Programm in den
korrekten Bereichen des Arbeitsspeichers arbeitet. Ebenfalls zur
Laufzeit kann man durch anklicken des entsprechenden Registers die
Registerinhalte ändern. Abbildung \ref{cr_sx_exe} zeigt das
Registerfenster der Entwicklungsumgebung im Debugmodus. In der Tabelle
sind alle Register aufgezählt. Zur Linken sieht man die Inhalte der
globalen Register sowohl in binärer als auch in hexadezimaler
Form. Desweiteren sind der Programmzähler (PC) und der Akkumulator (W)
am oberen Rand zu sehen.

\begin{figure}
  \center
  \includegraphics[width=200pt]{watchregs.eps}
  \caption{Formatierte Anzeige von Registern}
  \label{cr_watchregs}
\end{figure}


\begin{figure}
  \center
  \includegraphics[width=400pt]{regs_dbug_500.eps}
  \caption{Registerfenster mit Debugleiste}
  \label{cr_sx_exe}
\end{figure}

\subsection{Funktionsweise eines SX52 Assemblerprogramms}
Im folgenden wird die Funktionsweise eines SX52 Assemblerprogramms
grob umrissen, um ein besseres Verständnis der folgenden Erklärungen zu
ermöglichen. 

Die Programme des SX52 sind in einem 64 Kilobyte großem
Programmspeicher untergebracht. Jedes Byte hat eine Länge von zwölf
Bit. Ein Byte repräsentiert eine Instruktion für den Microcontroller.
Dabei teilt sich ein solches Byte je nach Befehl in Operationscode und
Argumente. Es handelt sich beim SX52 um eine RISC-Architektur, das
heißt der Anteil des Operationscodes an einer Instruktion ist (fast)
immer gleich. Die Adresse der aktuell auszuführende Zeile entnimmt man
dem Programmzähler (zu engl. Programm Counter, abgekürzt: PC).

Ein Programm beginnt an der höchsten Stelle des Speichers, also an der
Stelle FFF (Hexadezimal). Dort wird die Einsprungadresse des
Hauptprogramms eingelesen und in den Programmzähler geschrieben. Die
Einsprungadresse wird auch als ,,reset''\footnote{engl.reset:
  wiederherstellen. In diesem Kontext soll der Anfangszustand des
  Programms wieder hergestellt werden} bezeichnet. Der Befehl
an der aktuellen Stelle wird eingelesen und, nachdem der
Programmzähler um Eins iteriert wurde, ausgewertet.

Ein solches Programm könnte nun bis zur höchsten Stelle durchlaufen und
dann wieder von der Stelle FFF (hexadezimal) aus zurückspringen. In
der Praxis wird das jedoch selten so gehandhabt. Folgende Ereignisse
können den eben beschriebenen Kreislauf unterbrechen:

\begin{description}
\item[Rollover-Interrupt] Der Rollover-Interrupt\footnote{engl.roll
    over: überschlagen, vorne überkippen; engl. interrupt: die
    Unterbrechung} unterbricht das Programm, schreibt den
    aktuellen Inhalt des Programmzählers, sowie den Akkumulator und
    die Register FSR
  \footnote{FSR: File Select Register, enthält den Zeiger auf die
    Aktuelle Registerbank} und STATUS\footnote{STATUS: enthält den
    arithmetischen Status der ALU, sowie die Page Select Bits. Mehr
    dazu in Abschnitt \ref{cr_unterprog}} in eigens für die
    Interruptbehandlung vorgesehene Register. Danach werden die
    Befehle ab der Adresse 000hex ausgeführt bis das Ende des
    Interrupts durch einen speziellen Rücksprungbefehl angezeigt wird
    (hier: RETIW oder RETI). Diese Befehle sorgen nun dafür, daß der
    Programmzähler, der Akkumulator und die Register FSR und STATUS
    wieder auf die zuvor gespeicherten Werte zurückgesetzt werden. Die
    Befehle von der Adresse 000hex bis zum Rücksprungbefehl werden im
    folgenden als Interrupt-Routine bezeichnet.  Während der
    Ausführung einer Interrupt-Routine wird kein weiterer Interrupt
    erkannt.
  
\item[SLEEP-Befehl] Durch den SLEEP-Befehl wird die Clock
  ausgeschaltet und der Mikrocontroller nur
  noch minimal mit Strom versorgt. Das Programm hält an.
  
\item[Multi-Input-Wakeup-Interrupt] Der Multi-Input-Wakeup-Interrupt
  wird durch ein Signal am Port B ausgelöst. Er bewirkt entweder das
  ,,aufwachen'' des Mikrocontrollers, wenn dieser im SLEEP-Modus war,
  oder er startet die Interrupt-Routine.
  
\item[Endlosschleife] Man kann das Rrreichen der höchsten
  Speicherstelle auch durch eine eigene Endlosschleife verhindern, die
  während des Programmablaufes nicht verlassen wird.
  
\item[Neustart durch ab- und einschalten der Versorgungsspannung]
  Natürlich kann man den Mikrocontroller auch aus- und wieder
  anschalten um das Programm zu unterbrechen. Man führt also
  einen Hardware Reset durch.
\end{description}

Während des Programmablaufes werden Daten eingelesen, bearbeitet und
ausgegeben. Dies geschieht in den Registerbänken. Man Unterscheidet im
Fall des SX52 zwischen globalen und zu adressierenden Registerbänken
zu je 16 Byte (1 Byte = 8 Bit). Die globalen Register sind jederzeit
adressierbar. Sie enthalten unter anderen das STATUS-Register, das
FSR-Register und die Port-Register. Im FSR ( engl. File Select
Register, etwa Dateiauswahlregister) stehen die ersten vier Bit der zu
adressierenden Registerbank. Um eine Bank zu adressieren schreibt man
entweder die entsprechende Adresse direkt in das FSR-Register oder
nutzt den BANK-Befehl gefolgt von einer drei-Bit Nummer, das vierte
Bit im FSR wird dabei immer auf Null gesetzt. Um jetzt trotzdem die
ungeraden Registerbänke adressieren zu können muß der Programmierer
das entsprechende Bit im FSR-Register setzten. Diese umständliche
Handhabe ist auf die Kompatibilität mit dem SX32 zurückzuführen, der
nur acht Registerbänke zur Verfügung stellt.

\subsubsection{Unterprogrammaufrufe}\label{cr_unterprog}
Unterprogrammaufrufe werden mittels CALL-Befehl realisiert. Der SX52
enthält einen bis zu acht Einträge haltenden Stapel um Unterprogramme
verschachtelt aufzurufen.  Beim Aufruf eines Unterprogramms wird die
Rücksprungadresse auf den Stack gelegt und der Programmzähler auf den
Wert des CALL-Arguments gesetzt.  Das Argument kann jedoch nur einen
Adreßraum von 256 Byte ansprechen (Argumentlänge: acht Bit), drei der
restlichen vier Bit für eine vollständige Programmspeicheradresse
stehen im STATUS Register. Das vierte Bit wird automatisch auf Null
gesetzt. Für die Programmierung bedeutet dies, daß mit einem
Unterprogrammaufruf innerhalb einer Programmspeicherseite nur
Unterprogramme in der unteren Hälfte aufgerufen werden können. Im
Abschnitt \ref{cr_call_seg} wird ein Konzept beschrieben, das diese
Einschränkung geschickt umgeht.

\subsubsection{Arbeitsregister}
Der SX52 nutzt in der Summe 17 Registerbänke zur Verarbeitung von Daten zur
Laufzeit. Die Register teilen sich in eine globale Bank und 16
indirekt adressierbare Bänke auf (siehe Abbildung \ref{cr_register}).
Jede Bank enthält 16 Register. Für die
Adressierung der globalen Register sind keine Vorkehrungen nötig.  Um
ein solches Register zu adressieren benutzt man im Quelltext einfach die absolute
Adresse des Registers (direkte Adressierung). Um die 16 ,,normalen''
Registerbänke zu referenzieren, muß zuvor die entsprechende
Registerbank über das FSR angegeben werden. Erst dann kann man die
16 Register der entsprechenden Bank wählen. Das heißt, das nur die
unteren vier Bit von Relevanz sind. Um eine solche (indirekte)
Registeradressierung anzukündigen, müssen die ersten vier Bits (
MSB\footnote{Most Significent Bits: höchstwertige Bits}) eine 1
darstellen.
Steht also im Bit Nummer vier einer Registerreferrenz eine 1, so werden die
Bits 0 bis 3 für die Adressierung eines globalen Registers genutzt,
sonst wird ein Register aus der im FSR spezifizierten Bank entnommen.

\begin{verbatim}
; W bezeichnet den Akkumulator
MOV  $1A,W ; schreibt von W in das globale Register $1A
BANK $60   ; stellt FSR auf Bank sechs
SETB FSR.4 ; stellt FSR auf Bank sieben
MOV  $0A,W ; schreibt von W in das Register Nr.7A
\end{verbatim}

In der Summe stehen dem Benutzer 256 Register plus 15 globale Register
zur Verfügung. Von den globalen Registern sind die ersten fünf
Register für spezielle Aufgaben vorgesehen (unter anderen FSR und
STATUS-Register),dann folgen die fünf I/O-Ports die auch als Register
nutzbar sind, zuletzt verbleiben noch sechs ,,freie'' Register.

\begin{figure}
  \center
  \includegraphics[width=400pt]{register.eps}
  \caption{Aufbau der Registerbänke im SX52}
  \label{cr_register}
\end{figure}

\subsection{Assembler-Direktiven}

Der zum SX52 gelieferte Assembler stellt eine Reihe von Direktiven zur
Verfügung, die, klug genutzt, die Programmierung vereinfachen.  Eine
Direktive wird nicht zur Laufzeit, sondern bereits vor der
Programmierung des Programmspeichers ausgeführt. Sie dient zum
Beispiel zur Organisation des Programmcodes, zur Benennung von
Variablen und Konstanten, oder zur arithmetischen Überprüfung einiger
Programmkomponenten.  Im Folgenden werden einige der Direktiven
beschrieben. Ausserdem wird gezeigt, wie sie genutzt werden können, um die zuvor
formulierten Ziele in der Implementierung zu erreichen.

\subsubsection{EQU-Direktive}
Mit der EQU-Direktive werden Konstanten oder Registern Namen
zugeordnet, die dann beim Programmieren statt der Zahl bzw.
Registernummer genutzt werden kann.


\begin{verbatim}
LED EQU     RB.5        ; 6.Bit auf Port B wird mit LED benannt
FOO EQU     $0a         ; Register 0a wird mit FOO benannt
BAR EQU     #%0000_0011 ; Konstante BAR hat den Wert drei
\end{verbatim}

\subsubsection{ORG-Direktive}
Die ORG-Direktive dient der genauen Plazierung von Programmcode im
Programmspeicher. Man definiert eine Adresse zwischen $000hex$ und
$FFFhex$, an welcher der Programmcode dann im Programmspeicher stehen
soll .

Beispiel:
\begin{verbatim}
ORG  #000   ;der folgende Code wird ab Adresse 000 eingefügt
# Es folgt die Interrupt-Routine
...

ORG  #200   ;der folgende Code steht ab Adresse 200 (hex)   
MOV  $01, #2    
...
\end{verbatim}
\subsubsection{DS-Direktive}
Die DS-Direktive benennt einen Programmspeicherbereich. Die Größe des
Bereichs in Byte wird als Argument übergeben. Kombiniert man diesen
Befehl mit der ORG-Direktive, so kann man auch den Ort der
Reservierung festlegen.

\begin{verbatim}
ORG #20
FOO DS  1 ;reserviert ein Byte unter FOO
BAR DS  2 ;reserviert zwei Byte unter BAR
\end{verbatim}

\subsubsection{MACRO-Direktive}
Ein nützliches Werkzeug bei der Speicherorganisation ist die
MACRO-Direktive. Programmcode, der in ein Macro eingebunden wird läßt
sich leicht aus dem Programm entfernen und wieder einsetzen. Diese
Eigenschaft ermöglicht es, Programmteile genau zu plazieren und so
Adressierungsbeschränkungen zu umgehen. Mehr dazu in Kapitel \ref{Assembler-Module}


\begin{verbatim}
MACRO   FOO ; Macro namens FOO

MOV M,#BAR  ; Programmcode

ENDM ; Ende dees Macros
.
.
.
ORG 200
FOO     ; Macro FOO wird bei 200 (hex) eingefügt
\end{verbatim}

\subsubsection{\$-Direktive}
Das Dollarzeichen liefert die Adresse der aktuellen Bank zurück.
\begin{verbatim}
FOO EQU $   ;FOO enthält die aktuelle Adresse
\end{verbatim}

\subsection{Assembler-Module}
\label{Assembler-Module}

Ein Ingenieur, der die Aufgabe erhält ein SX-Assemblerprogramm zu schreiben,
wird mit einigen gefährlichen Schwierigkeiten konfrontiert.
Um potentielle Fehler beispielweise mit Unterprogrammaufrufen. Speicherbelegung,
Registerzugriff etc. zu vermeiden, bietet sich die im Rahmen dieser Arbeit
entwickelte Modulstruktur an.

Bei der Konzeption der Module galt es, die potentiellen
Schwierigkeiten mit Unterprogrammaufruf, Verteilung der Programmteile
auf dem Speicher, sowie den Zugriff auf Register für den Entwickler
möglichst einfach handhabbar zu machen.  Um dies zu erreichen eignet
sich eine Modulstruktur die durch geschicktes Einsetzen der
Makro-Direktiven die oben genannten Schwierigkeiten umgeht.

\subsubsection{Modulstruktur}
Man unterteilt jedes Modul in verschiedene Segmente. Begreift man nun
ein Assemblerprogramm als Automat mit den Zuständen Initialisierung,
Hauptfunktion und Interrupt (siehe Abbildung \ref{Automat}) , so repräsentieren grob betrachtet
die einzelnen Segmente die Zustände des Automaten.

\begin{figure}
  \center
  \includegraphics[width=400pt]{Automat.eps}
  \caption{Ein Assemblerprogramm als Automat}
  \label{Automat}
\end{figure}

Zusätzlich bedarf es für die Datenorganisation noch eines CALL- und eines
DATA-Segments. Im folgenden die Segmente im Einzelnen.

\begin{description}

\item[CODE-Segment:] Im CODE-Segment befinden sich die eigentlichen
  Routinen eines Moduls. Jede Routine beginnt dabei mit einer
  Einsprungmarke und endet mit einem Rücksprungbefehl für
  Unterprogramme. Der Rücksprungbefehl setzt die durch einen
  CALL-Befehl gespeicherten Werte in STATUS-, FSR-Register und
  Programmzähler wieder ein, und führt das Programm von dort an weiter
  aus.

\item[CALL-Segment:]\label{cr_call_seg} Das Call-Segment dient dazu die
  256-Byte Grenze des CALL-Befehls zu umgehen. Dieses Segment muß
  jeweils in den unteren 256-Byte einer Programmspeicherseite liegen.
  Im CALL-Segment werden Funktionsnamen mit den entsprechenden
  Funktionen im CODE-Segment verknüpft. Der Trick liegt dabei in der
  Verwendung des JMP-Befehls. JMP springt an die im Argument
  übergebene Stelle im Programmspeicher. Da das Argument des
  JMP-Befehls neun Bit lang ist, können die vollen 512 Byte einer
  Speicherseite referenziert werden.  Das CALL-Segment ermöglicht also
  einen Unterprogrammaufruf ohne die 256-Byte Beschränkung bedenken zu
  müssen. Desweiteren fügt der Assembler noch einen PAGE-Befehl ein
  wenn dem CALL ein @ vorangestellt wird, so daß auch die
  Beschränkung auf die aktuelle Seite des Speichers wegfällt.

\item[DATA-Segment:] Wie bereits oben beschrieben stehen dem
  Programmierer 256 Register auf verschiedenen Bänken zur Verfügung.
  Um mit den Registeradressierungen nicht durcheinander zu kommen,
  empfiehlt es sich pro Modul nur auf einer Bank zu arbeiten.  Die
  Makros ermöglichen es bei der Programmierung auf bewußte
  Registeradressierung zu verzichten, indem man nur noch mit Variablennamen hantiert.

  Man definiert also ein Makro in dem Platz für maximal 16 Register
  reserviert wird. Bei der Reservierung wird die Speicherstelle
  zwangsweise benannt, sodaß beim programmieren, wie bereits gesagt,
  nur noch die Variablen für den reservierten Platz benutzt werden
  können.  Um dann das Makro einer Registerbank zuzuordnen, wird das
  Makro durch die ORG-Direktive an der entsprechenden Stelle
  eingefügt. Die erste Instruktion im Makro weist dann einer Variablen
  die aktuelle Adresse zu, so daß der Entwickler mit der Kombination
  BANK-Befehl und eben genannte Variablen die entsprechende Modulbank
  referenzieren kann ohne schon bei der Implementierung wissen zu
  müssen, welche Bank er eigentlich nutzt.

\begin{verbatim}
MACRO     FOO   ; Macro namens FOO
MEINEBANK $     ; Die aktuelle Bank wird referenziert
VAR1      DS1   ; Ein Register reservieren
VAR2      DS1   ; ...
...
ENDM

ORG  $20
FOO     ; Macro FOO wird bei 20 (hex) eingefügt
                ; enspricht der dritten Bank
\end{verbatim}
  
\item[INTERRUPT-Segment:] Benötigt man für ein Modul auch Routinen die
  durch einen Interrupt ausgelöst werden, so schreibt man den dazu
  nötigen Code in ein Makro.  Dieses Makro wird als Interrupt-Segment
  beschrieben. Die Interrupsegmente schreibt man dann hintereinander
  an die Adresse 000 (hexadezimal). In den Interruptsegmenten darf
  kein Interrupt-Rücksprungbefehl (RETI oder RETIW) stehen. Der muß
  am Ende der Makroliste stehen, so daß alle Segmente
  vor Beendigung der Interruptroutine ausgeführt werden.

\item[INIT-Segment:] Jedes Modul benötigt auch einen Bereich im
  Initialbereich des Gesamtprogramms zur Initialisierung seiner
  Variablen. Dazu definiert man zu jedem Modul ein INIT-Macro.
\end{description}

Zusammengefaßt könnte ein Programm nach den oben beschriebenen
Konventionen dann wie folgt aussehen: \small{
\begin{verbatim}
;M O D U L E
; Modul_1

; DATASEGMENT
    MACRO   DATA_MODUL_1
     MEINEBANK $     ; Die aktuelle Bank wird referenziert
     VAR1      DS1   ; Ein Register reservieren
     VAR2      DS1   ; ...
    ENDM
    
; INTERRUPTSEGMENT
    MACRO   INTERR_MODUL_1
    ;Anweisungen die bei Interrupt ausgeführt werden sollen
    ENDM
    
; INITSEGMENT
    MACRO   INIT_MODUL_1
    BANK MODUL_BANK_1  ; Auf Modulspezifische Bank wechseln
    ;Initialisierung der Variablen
    ENDM
    
; CALLSEGMENT
    MACRO   CALL_MODUL_1
     routine_1
     JMP _routine_1 
    ENDM
    
; CODESEGMENT
   MACRO   CODE_MODUL_1
   _routine_1 ;Sprungmarke für CALL-Segment
   ; der eigenliche Code
   ...
   ENDM

; Modul_2
...
; CALLSEGMENT
    MACRO   CALL_MODUL_2
     routine_2
     JMP _routine_2
    ENDM
    
; CODESEGMENT
   MACRO   CODE_MODUL_2
   _routine_2 ;Sprungmarke für CALL-Segment
   ; der eigenliche Code
   ...
   ENDM
...
; Modul_3
...

;P R O G R A M M
Hier wird jetzt der Programmcode auf den Speicher verteilt

ORG $000
;Interrupt
INTERR_MODUL_1
INTERR_MODUL_2
INTERR_MODUL_3
RETI ;aus Interrupt herausspringen

ORG $500 
main        ;anfängliche Einsprungmarke
;Initialisierung
;Interrupt abschalten
...
;allgemeine Konfiguration
...
INIT_MODUL_1
INIT_MODUL_2
INIT_MODUL_3
;Interrupt wieder einschalten
mainprog   ; Hauptteil des Programms
...
@CALL routine_1
...
@CALL routine_2
...
JMP mainprog

ORG $600
CALL_MODUL_1
CALL_MODUL_2
CODE_MODUL_1
CODE_MODUL_2

ORG $800
CALL_MODUL_3
CODE_MODUL_3
\end{verbatim}
}
\subsubsection{Datenaustausch zwischen den Modulen}

Um den Austausch von Daten sicherzustellen, werden zwei Bänke
reserviert. Jedes Modul entnimmt dort seine
Eingabewerte und legt die Ergebnisse dort wieder ab.

\section{Implementierungen}
Im Folgenden werden beispielhaft Module für einige Bauelemente
beschrieben.

\begin{description}
\item[Serielle Schnittstelle:]\label{crRS232} Die serielle
  Datenübertragung ist in der Norm RS232 festgelegt. Der Standard definiert
  die nötigen Physikalischen Größen, sowie die Verkabelung. 
  Das beschriebene Modul implementiert eine vereinfachte Version
  (d.h. es werden nicht alle Kabel genutzt), die
  für unsere Zwecke vollkommen ausreichend ist. 
  Danach können zwei Computer über die Datenleitungen TxD (Transmit Data) und RxD
  (Receive Data) miteinander kommunizieren. Ein Byte wird in unserem
  Fall im 8n1 Modus gesendet. Das heißt es werden acht Bits, sowie ein
  vorangestelltes Startbit und ein nachgestelltes Stopbit
  gesendet. Eine Fehlerüberprüfung (Parity) findet bei der
  Implementierung in diesem Fall nicht statt.  Es handelt sich bei der
  RS232 um eine asynchrone Übertragung die, im Gegensatz zur
  synchronen Übertragung, ohne separates Taktsignal erfolgt.  Ein
  Empfänger muß das eintreffende Signal mit dem mehrfachen der
  möglichen Taktfrequenz abtasten und so das Taktsignal
  rückgewinnen. Um
  sicherzustellen, daß ein Eingangssignal registriert
  wird, wählt man als Abtastrate das vierfache der Zielfrequenz ab.
  Um beispielsweise bei einer Zielfrequenz $F$ von $115.200 Baud$ eine
  Änderung der eingehenden Flanke festzustellen, wird der
  Eingangszustand mit $460,8 kHz$ abgetastet.  Um ein genaues Timing
  zu realisieren nutzt die Implementierung den Rollover Interrupt. Der
  Rollover Interrupt löst alle 256 Zyklen einen Interrupt aus. Dies
  entspricht bei einer Taktfrequenz $T$ von $50 MHz$ einem Takt von
  $195.312,5 Hz$. Reduziert man nun die Anzahl der Zyklen bis zum
  nächsten Interrupt, so läßt sich die Interrupt-Frequenz regulieren.
  Der Befehl RETIW macht das möglich. RETIW setzt den Interruptzähler
  auf den im Akkumulator W übergebenen Wert.  So läßt sich mit 108
  Zyklen pro Interrupt, bei einer Zyklenlänge von $20 ns$, ein Takt von ungefähr $115.200 Baud$
  realisieren (vierfache Abtastrate).  In diesem Beispiel wird davon
  ausgegangen, das im Interrupt keine weiteren Verzögerungen
  auftreten. Wenn jedoch mehrere Module mit Interrupt-Segmenten
  genutzt werden, so muß die Verzögerung beim setzen des neuen
  Rollover Interrupt berücksichtigt werden.  Für eine Anzahl $n$ von
  Zyklen im Interrupt ergibt sich der zu übergebende Wert $w$ für der
  Akkumulator wie folgt:
\begin{displaymath}
w = \left\lfloor \frac{T}{4*F} \right\rfloor - n
\end{displaymath}
mit $w \gg 0 $.

$w \gg 0$ deutet darauf hin das die Interruptroutine nicht zu groß ausfallen
sollte, da sonst die Ausführung sonstiger Programme zu kurz kommt.
Nutzt man also das Modul, so muß zuvor eine Baudrate für die serielle
Übertragung festgelegt werden, und im Interrupt-Segment eingetragen zu
werden. Für die Platine ist eine Baudrate größer als 115.200 nicht
empfehlenswert, da sonst die eigentlichen Programmteile nicht mehr
ausreichend Zeit zur Ausführung bekommen. Mehr zur seriellen Schnittstelle
sowie ihren Nutzungsvarianten findet sich in \cite{RS232Fun}.

\item[Puls Weit Modulation:]\label{cr_puls}Mittels Puls-Weit-Modulation
  läßt sich an digital angesteuerten Geräten analoges Verhalten
  erzeugen.  Dabei wird die Trägheit der jeweiligen
  elektromechanischen Gerätes ausgenutzt um die digitalen Impulse zu
  einer monoton steigenden Funktion zu ,,wandeln''.  Man unterteilt
  ein Zeitintervall $I$ äquidistant in $n$ kleinere Zeitintervalle
  $z_{i}$ mit $i = 0,...,n$.  Geht man davon aus, daß ein Ausgang zwei
  Zustände $low$ und $high$ einnehmen kann, und das jedes
  Zeitintervall $z_{i}$ mit dem Zustand $low$ beginnt. In jedem
  Zeitintervall $z_{i}$ wählt man dann ein $t_{i}$ mit $0 < t_{i} <
  |z_{i}|$ ab welchem der Wert des Ausgangs auf $high$ geht.  Die
  Größe $t_{i}$ bestimmt dann die Intensität mit der das am Ausgang
  angeschlossene Gerät betrieben wird.  Im folgenden wird $t_{i}$ auch
  Pulsweite genannt.  Ein angeschlossener Gleichstrommotor zum Beispiel
  dreht sich bei $t_{i} = 1/2 z_{i}$ nur halb so schnell als er es bei
  durchgehendem Stromfluß tun würde.
  Ändert man nun $t_{i}$ zur Laufzeit in die eine oder andere Richtung, so erzeugt
  man Dimm-Effekte.  Ein Beispiel ist die Funktion $t_{i}=i*z_{i}/n$,
  die $t-{i}$ mit jedem Schritt an $n$ annähert und damit von $low$
  nach $high$ übergeht. Ein Beispiel findet sich in Abbildung \ref{cr_pwm}:
  
  Die fallende Flanke des PWM-Signals markiert hier jeweils das Ende eines Intervalls $z_i$.
  Die dunklen Flächen markieren die Plusweiten $t_i$. Durch zunehmende Pulsweiten wird die lineare Funktion simuliert.
  
  Auf der Platine sind die Brücken und die PWM-baren Low-Side-Switchs
  für die Puls-Weit-Modulation vorgesehen.  Ein $z_{i}$ entspricht 256
  Interrupts. In jedem Interrupt wird ein Zähler iteriert bis dieser
  überläuft. Bei jedem Übelauf wird der Zustand auf $low$ bzw $high$
  gesetzt (je nachdem ob von Aus nach An oder umgekehrt moduliert
  wird). Im Hauptprogramm (CODE-Segment) wird dann der Zähler mit
  einer Variable verglichen, die die Pulsweite bestimmt. Je nach
  Anwendung kann man nun die Pulsweite verändern, indem man sie
  inkrementiert oder dekrementiert bzw. unterschiedlich initialisiert.
%reverse iterations
\begin{figure}
  \center \includegraphics[width=400pt]{pwm.eps}
  \caption{Puls Weit Modulation einer linearen Funktion.}
  \label{cr_pwm}
\end{figure}

\item[Serial Peripheral Interface:] Um eines der Geräte über den SPI-Bus zu adressieren, muß
  das betreffende Gerät per Chip-Select aktiviert werden.  Wie in
  \ref{cr_SPI-Bus} beschrieben erfolgt die Aktivierung der einzelnen
  Geräte über einen Multiplexer, der über die Pins drei bis fünf am
  Port D an den SX52 angeschlossen ist.  Die folgenden Konstanten
  repräsentieren die Pinbelegungen des Port D für die einzelnen
  Geräte:
\begin{verbatim}
SPI_TLE1        EQU %0000_0000 ; Low-Side-Switch
SPI_TLE2        EQU %0000_1000 ; Low-Side-Switch
SPI_ADC         EQU %0001_0000 ; Analog-Digital-Wandler
SPI_DAC         EQU %0001_1000 ; Digital-Analog-Wandler
SPI_CAN         EQU %0010_0000 ; CAN-Controller
SPI_RESET       EQU %0010_1000 ; RESET aller RESET-fähigen Geräte
SPI_NOTCON      EQU %0011_0000 ; zu keinem Gerät verbunden
\end{verbatim}
  Das Bitmuster SPI\_NOTCON kann genutzt werden um sicher zu gehen,
  das kein Gerät angewählt ist, so daß man bei der Programmierung
  nicht auf die Pinbelegungen auf Port D achten muß.  Wenn das Gerät
  ausgewählt ist, erfolgt gerätespezifisch die Übertragung
  verschiedener Bitmuster.  Im Detail werden die Geräte wie folgt
  behandelt:
\begin{description}
\item{TLE:} Es werden zwei 8-Bit Wörter in den Low Side Switch
  übertragen. Das erste Wort Konfiguriert die Switches für die
  einzelnen Pins, das zweite aktiviert die Einstellung dann
  gegebenenfalls.
\item{ADC:} Noch bevor der Analog-Digital-Wandler per Chip-Select
  aktiviert wird, werden vier Bit zum auswählen des zu wandelnden Eingangs
  übertragen, erst nachdem Chip-Select auf $low$ gesenkt wurde,
  wird nach kurzer Verzögerung das Ergebnis an den Mikrocontroller
  geschickt.
\item{DAC:} Zwei $\times{}$ 12 Bit werden in das Shift-Register des
  Digital-Analog-Wandlers übertragen und dann, beim Wechsel des
  Chip-Select Signals von $low$ nach $high$, aktiviert. Das heißt die
  analogen Interpretation der 12-Bit-Muster liegen in Volt an den
  Ausgängen des Digital-Analog-Wandlers an.
\item{CAN:} Der CAN-Controller wird über einen Instruktionensatz
  von fünf Befehlen gesteuert. Ab der fallenden Flanke des 
  $\bar{CS}$ Signals erwartet der Controller eine Befehlseingabe auf jeder 
  steigenden Flanke der CLock-Leitung. Allen Befehlen gemein ist, daß in den ersten
  acht Bit der Befehlscode steht und dann, sofern nötig, die Adresse
  des betreffenden Registers im Pufferspeicher des CAN-Controllers.
  Zuletzt folgen die Argumente des Befehls, bzw eventuelle Rückgebewerte
  werden gelesen. Gesendet werden die im Pufferspeicher gesetzten
  Einstellungen durch den Befehl Request to Send (RTS).
\end{description}

\item[Speicher] Der Speicher ist über eigene Anschlüsse an den Mikrocontroller angeschlossen.
Über eine serielle Datenleitung erfolgt der Datentransfer. Für jede Operation (ob schreiben oder lesen) , wird
  das Gerät über die Bits 1 bis 3 der ersten 8 Bit adressiert. In den
  Bits 7 bis 4 steht die Slave ID (hier 1010). Das nullte Bit zeigt an,
  ob eine Lese- (1) oder Schreibe-Operation (0) anschließt. Nach der
  Adressierung sendet der Master (hier der Mikrocontroller) beliebig viele acht-Bit Worte und
  erhält nach jedem Word eine Bestätigung (engl. acknowledge) vom
  Speicherbaustein.  Bei der Lese-Operation unterscheidet man zwischen
  sequentiellem Lesen und selektivem Lesen.

  Beim sequentiellen Lesen werden vom Master dem oben beschriebenen
  Adressierungsbyte zwei Byte mit der Speicheradresse des gesuchten
  Wortes übertragen. Ab diesem Zeitpunkt beginnt der FM24C64 mit dem
  Senden des Worts aus der adressierten Speicheradresse. Nach jedem
  Byte wird wieder eine Bestätigung gesendet und das im Speicher
  folgende Wort kann sequentiell ausgelesen werden ohne erneut
  adressieren zu müssen. 

  Beim selektiven Lesen beginnt der Master wie bei einer
  Schreibeoperation (LSB = 0). Er schreibt das Adressierungsbyte und
  spezifiziert mit den folgenden zwei acht-Bit Worten die
  Speicheradresse. Nachdem der FM24C64 den Eingang der Speicheradresse
  bestätigt hat setzt der Master eine Start-Signal ab.  Dadurch wird
  der Schreibmodus abgebrochen. Wenn der Master jetzt direckt im
  Anschluß das Adressierungsbyte mit gesetzten Lesebit sendet geht der
  FM24C64 in den sequentiellen Lesemodus über.
\end{description}

\newpage
\section{Fazit}

Das Konzept der multifunktionalen Platinen, die potentielle Periepeheriegeräte steuern 
ist aufgegangen. Das dies nicht
%nur aus der Sicht eines Informatikers gilt, hat die Schulung des
Münchner Projektteams im Mai 2002 gezeigt.  Bereits jetzt sind
Maschinenbauer in München dabei die Steuerung eines Lichtsystems und
einer ausfahrbaren fahrzeugstütze mit Hilfe der Platine zu
realisieren.  Auch in Zukunft wird die Platine in München in anderen
mechatronischen Projekten genutzt werden. Ebenso hat die Arbeit
gezeigt wie wichtig der Austausch zwischen den Teammitgliedern und den
beteiligten Disziplinen für eine adäquate Anforderungslösung
ist. Während der Entwicklung wurden immer wieder Rücksprachen mit den
Maschinenbauern geführt um die Implementierung an deren Bedürfnisse
anzupassen.

Dennoch würde ich, könnte ich dieses Projekt mit meinem jetzigen Wissen
erneut beginnen, meine Prioritäten bei der Wahl des Microcontrollers ändern.
Schwerpunkte wären dann nicht mehr Preis und Geschwindigkeit, sondern 
C-Programmierbarkeit (also ob ein zumindest kostengünstiger C-Compiler
für den Microcontroller erhältlich ist) und integrierte Kommunikationslogik.
Die zeitkritischen Elemente wie serielle Schnittstelle und CAN wären dann
nicht mehr zu implementieren, womit die hohe Geschwindigkeit des 
Microcontrollers hinfällig wird. Desweiteren könnte man auf PDA
und Platinenseite die gleiche API zur Verfügung stellen.

Persönlich habe ich durch diese Studienarbeit viel über die Elektotechnik
und ihre Tücken gelernt. Die Arbeit im Team, d. h. Terminabsprachen, Meilensteine 
der Arbeit und ihr Abgleichen mit den anderen Gebieten des Projekts
(insbesondere vor der CeBit) sowie der fachliche Austausch untereinander
zählen zu den reichsten Erfahrungen aus dieser Arbeit.

% Die Wahl des Mikrocontrollers hat sich als richtig erwiesen, da sich
%eine gut handhabbare Programmstruktur erstellen lies. Das dies nicht
%nur aus der Sicht eines Informatikers gilt, hat die Schulung des
%Münchner Projektteams im Mai 2002 gezeigt.  Bereits jetzt sind
%Maschinenbauer in München dabei die Steuerung eines Lichtsystems und
%einer ausfahrbaren fahrzeugstütze mit Hilfe der Platine zu
%realisieren.  Auch in Zukunft wird die Platine in München in anderen
%mechatronischen Projekten genutzt werden. Ebenso hat die Arbeit
%gezeigt wie wichtig der Austausch zwischen den Teammitgliedern und den
%beteiligten Disziplinen für eine adäquate Anforderungslösung
%ist. Während der Entwicklung wurden immer wieder Rücksprachen mit den
%Maschinenbauern geführt um die Implementierung an deren Bedürfnisse
%anzupassen.

\section{Ausblick}
Die Grundlagen für die Nutzung der Platine sind geschaffen. Um den
Gebrauch noch komfortabler zu gestalten ist es wünschenswert, eine
didaktisch ausgereifte Anleitung auf Basis der bereits gehaltenen
Schulung zu erstellen. Darüber hinaus ist eine ausführliche technische
Dokumentation wünschenswert.
%Anleitung
%C-Compiler
%Techn Docu
