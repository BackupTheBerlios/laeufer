\section{Anforderungen an die Peripherieelektronik}
\subsection{Gesamtkonzept}
Die Mechatronik im Projekt L"aufer muß einer Reihe projektspezifischer Anforderungen standhalten. Was bedeuten also die eingangs geschilderten
Zielsetzungen für die Peripherieelektronik?

Da sich der genaue Funktionsumfang aller mechatronischen Komponenten f"ur die Zukunft nicht abschätzen l"asst, und neue Komponenten jederzeit einfach
einzugliedern sein sollen muss das System leicht erweiterbar sein. Für die  Zielgruppe zur Nutzung der Platinen sind die Peripheriegeräte des L"aufers
muss das System mit vertretbarem Aufwandt bedienbar sein. Für den nutzenden Ingeneur muss der Effekt und nicht der Weg interessant sein.
Die begrenzten Resourcen eines autnomen Systems wie dem L"aufer erfordern außerdem eine sparsame Nutzung von Energie.
Um die Fahrer nicht durch Fehlfunktionen oder Ausfall eines Gerätes zu gefährden muß das System betriebssicher sein. D.h. sowohl in der physikalischen
Auslegung als auch in der Implementierung m"ussen m"ogliche Extreme in der Nutzung des Fahrzeugs ber"ucksichtigt werden. Dies beinhaltet auch eine
gewisse Fehlertoleranz mittels ,,fail save Design''.
Nicht zuletzt muss die Lösung zum einen durch das vorhandene Know How im Umfeld des Projekt L"aufer umsetzbar als auch finanzierbar bzw. durch
Sponsoren erhältlich sein.
Bei der Zusammenstellung der Platine muss ausserdem auf Verf"ugbarkeit der Bauelemente sichergestellt sein.
Zu guter letzt muss eine Platine wenig Raum einnehmen um dem Design des Fahrzeugs gr"oßtm"oglichen freiraum zu gew"ahren.

Zusammengefasst ist das Ziel der Arbeit eine im mechatronischen Bereich vielseitig und einfach bedienbare Platine zu erstellen sowie die
Implementierung einer Grundfunktionalität.
Im folgenden wird die Umsetzung der Anforderungen im Detail besprochen.

\subsection{Flexibilit"at}
Der CAN-Bus macht ein einfaches Einklinken in den Bus an jeder erdenklichen Stelle möglich. Dadurch ist das Gesamzkonzept schnell erweiterbar.
Ein neueres Gerät erhält eien eindeutige Identifikationsnummer und wird dann durch den PDA erkannt und gesteuert. Näheres dazu findet sich im Protokollteil wieder.
Die Platine ermöglicht das Anschließen unterschiedlicher Geräte ohne sich um Protokollfragen kümmern zu müssen.
Die Wahl der Microcontrollers und der elektronischen Bausteine lassen dem Entwickler größtmögliche Freiheit bei der Wahl der Funktionalität des
Peripheriegerätes. Das Layout der Platine erlaubt bei entsprechender Dimensionierung der Widerstände und Kondensatoren eine Versorgungsspannung von
5 bis 48 Volt. Ein Spannungswandler regelt dann die Spannung auf die für MOS-technologie üblichen 5 Volt herunter um die Bauelemente entsprechend zu
versorgen
\subsection{Kosten}
Die Platine enthält lediglich Standardbauelemente wie sie auch in der Automobilindustrie verwendet werden. Die Kosten einer komplett bestückten Platine
belaufen sich auf etwa 150,- \geneuronarrow{}. das Layout erlaubt jedoch eine Teilbestückung die sich auf die für ein spezifisches Peripheriegerät notwendigen
Bauelemente beschränkt. Ein weitere wichtger Punkt bei der Kostenbestimmung war die Verwendbarkeit und das Zusammenspiel der Bauelemente in der
gewünschten Zusammenstellung. Um gravierende Fehler auszuschließen und alle Vorstellungen umzusetzen begleitete die Firma Cetron den gesammten Prozess der
Platinenentwicklung. Von der Idee, dem Prototypen, der Auswahl der Komponenten, des Microcontrollers, dem Layout der Platine in zwei Revisionen bis 
hin zur Suche nach Sponsoren für 12 4-Layer Platinen sowie bei der Bestückung derselben stand die Firma Cetron mit Rat und Tat bei.

Die genauen Kosten der Platine hängt nicht unwesentlich von der Wahl der Komponentendistributoren ab. Preisunterschiede von bis zu 400 \% (z.B. bei
blauen LEDs) sind keine
Seltenheit. Eine sorgfältiger Preisvergleich der möglichen Lieferanten ist wichtiger Bestandteil der Kostenbestimmung.
\subsection{Sicherheit}
Zum Schutz vor Strom und Spannungsspitzen sowie weitestgehend vor falscher Bedienung durch einen Entwickler wurde bei der Auswahl der Komponenten als
auch beim Layout auf Robustheit Wert gelegt. Die Platine sowie die Bauelemente enthalten eine Reihe von Schutzmechanismen wie Zener-dioden oder eine
,,Schmelzsicherung'' in Form einer besonders dünnen Leiterbahn.
Der zweite wichtige Sicherheitsaspekt liegt in der Funktion eines etwaigen Gerätes. Hierzu sind die Nutzer der Platine angehalten einen fail save
Zustand zu implementieren. Eine entsprechende Nachricht auf Protokollseite existiert bereits.
\subsection{Design}
Um sich in das Design des Läufers zu integrieren sind sowohl die Erweiterbarkeit als auch die simple Grösse der Platine von Wichtigkeit.
Die Erweiterbarkeit ist bereits im Bereich Flexibilität beschrieben. Die Größe der Platine beträgt ca. 4,5cm * 8,6 cm, hat also etwa die Grösse einer Checkkarte.

\begin{figure}
  \center
  \includegraphics[width=277pt]{Platine_C-Karte.eps}
  \caption{Grössenvergleich Platine Cheque Karte}
  \label{Platine-Karte}
\end{figure}


\newpage
\section{Wahl der Komponenten}
%Komentar zur interdiszipl. Erörterung der Anforderungen
\subsection{Microcontroller}

%HC-Familie Motorola

%8051-Familie 
%-Infineon
%SAB80C35
%xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
%Intels 8-Bit Industriestandard:
%Vom 8008 zu 8080 und 8085, Vergleich mit Zilog Z80 22.4.2002 

%Preiswert und leistungsfähig:
%Motorola 6800 und 6809 im Vergleich zu MOS 6502 

%Die 16Bit-Ära
%Die Konkurrenten:
%Intel 8086/88 vs. Motorola 68K 29.4.2002

%Texas Instruments TI9900, Zilog Z8000 und National Semi. NS16016

%Von 16 auf 32Bit:
%Intel 80286-486 und Pentium(I) vs. Motorola 68020-060 und NS16032 
%xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

%SAB80C166

%SAB C167LM

%80C31

%68HC11

%HC12-Familie Motorola

%MC68HC812A4

%8-16-32 bit MCs

%PIC by Microchip


%Taktfrequenz
%Preis
%Erhältlich
%Entwicklungsumgebung


Die Wahl des Microcontrollers beruht auf der Empfehlung der Firma Cetron. Im folgenden werden im groben die Eigenschaften beschrieben. Weitere Details
stehen im Teil \ref{Konzeption} Konzeption der Implementierung.

Die Wahl des Microcontrollers fiel auf den SX52. Dieser Microcontroller der Firma Ubicom hat 16 Seiten Programmspeicher a 512 12-Bit Worten für den 
Programmcode und 16 $\times$ 16 8-Bit Registerbänke sowie eine Spezialbank zur Konfiguration. Das heißt es stehen 8 Kilobyte (1 Byte = 12 Bit) für
Programmcode und $2^{8}$ 8-Bit Register zu Laufzeit zur Verfügung. Für Unterprogrammaufrufe steht ein Stapel mit einer Tiefe von acht Einträgen zur
verfügung. Der Programmspeicher entspricht physikalisch einem Flashrom, sodaß das zum Beispiel weiterentwickelte Versionen auch im nachhinein
eingespielt werden können. Diese Möglichkeit erleichtert auch die Entwicklung insofern als das Programme nicht erst in simulierter Umgebung getestet
werden muss, sondern sofort im Einsatzumfeld erprobt werden kann ohne große Kosten zu verursachen.

Der SX52 hat fünf 8-Bit Ports die sowohl als Input als auch als Output nutzbar sind. Es existiert ein Stromsparmodus (Sleep-mode) der zur Laufzeit an- und ausschltbar
ist. Der Microcontroller hat eine Interrupt-funktion die ebenfalls zur Laufzeit aktivier und deaktivierbar ist. Einer der fünf Ports kann als
Interrupt oder Weck-port konfiguriert werden. Das heißt ein Signal an diesem Port löst einen Interrupt aus bzw. ,,weckt'' den Mocrocontroller aus dem
Stromsparmodus. 

Ein Besonderheit des SX ist ein komerziell erhältliches Programmierpaket, mithilfe dessen ein Programm schrittweise ausgeführt und sowohl auf
Bildschirm als auch am Microcontroller verfolgbar ist. Nähers dazu im Kapitel \ref{Umgebung} Programierumgebung.
Dies macht die Programmierarbeit deutlich einfacher.

Die Assemblersprache die der mitgelieferte Interpreter akzeptiert ist PIC-kompatiebel, so das im Internet Lösungen zu häufigen Problemen auzufinden
sind.

Mit einer Taktfrequenz von 50 MHz ist der SX auch für eine 115 Baud übertragung an der seriellen Schnittstelle schnell genug.
Weitere für die Programmierung relevante Merkmale werden im Kapitel \ref{Implementierung} Implementierung besprochen.
\subsection{Peripherie}
Um eine flexible Nutzung der Platine zu sichern gilt es eine Vielzahl von Anschlußmöglichkeiten zur Verfügung zu stellen. Im folgenden werden die
genutzen Bauelemente und Funktionalitäten der Platine beschrieben.
\begin{description}
\item[Serial Peripheral Interface (SPI)]
\label{cr_SPI-Bus}
Die große Anzahl an Bauelementen macht eine sparsame Nutzung der I/O-Ports am Microprozessor nötig.
Zu diesem Zweck sind der CAN-Bus-Chip, zwei Low-Side-Switches, ein Analog-Digital-Wandler und ein Digital-Analog-Wandler über ein SPI-Bus System mit
dem Microcontroller verbunden. Jeder dieser Bausteine hat einen Chipselect-Eingang der bei einer logischen Null den jeweiligen Baustein aktiviert. Der
Datentransfer geschieht dann zwischen Microcontroller und dem selektierten Baustein. 

Das jeweilige Chipselect wird über einen Multiplexer gesetzt. Diese Lösung spart nicht nur wertvolle Pins am Port des Microcontrollers, sie garaniert
auch das keine zwei oder mehr Geräte auf den Datentransfer reagieren.
\item[Kommunikation]
Neben dem SPI-Bus zur internen Kommunikation stehen eine serielle Schnittstelle und, wie bereits im vorangegangenem Kapitel
beschrieben, ein CAN-Bus für die externe Kommunikation zur Verfügung. 
Die serielle Schnittstelle ist direkt über einen Wandlerbaustein (MAX202CSE) mit dem Microcontroller verbunden. Durch die Anbindung des 
RXD- (RXD = Receive Data) und CTS-Signals (CTS = Clear To Send) an den weckfähigen Port des Microcontrollers ist eine Aktivierung der Platine über die
serielle Schnittstelle möglich.
\item[Digital-Analog-Wandler]
Angeschlossen an den SPI-Bus werden die Auszugebenden Spannungen mit 12 Bit codiert. So kann linear eine Spannung von 0 bis 12 Volt dargestellt werden.
Der Baustein von Linear Technologie LTC 1446 enthält zwei Digital-Analog-Wandler, so das insgesamt 24 Bit (2 $\times$ 12) über dan Bus übertragen werden
müssen.

\item[Analog-Digital-Wandler]
Der LTC 1594 von Linear Tchnologie enthält einen 4-Kanal Multiplexer über den einer von vier Eingängen an den Analog-Digital-Wandler geführt werden
können. Der LTC 1594 ist ebenfalls über den SPI-Bus erreichbar. Zur Konfigurations werden anfangs vier Bit übertragen die zum einen als Aktivierung und zum anderen für die Auswahl des Multiplexereingangs.
Wenn ein Eingang ausgewählt ist, dann codiert der Analog-Digital-Wandler die anliegende Spannung bis maximal 12 Volt in 12 Bit. Die Abtastrate beträgt
16,8 kHz.

Über Jumper lässt sich eine Rückkopplung der Brückenausgänge mit den Eingängen des Anlog-Digital-Wandlers herstellen.
Der Strom an der Brücke wird über einen Widerstand geführt, die abfallende Spannung mit einem Operationsverstärker verstärkt und dann im
Analog-Digital-Wandler gemessen.
Das heißt es existiert eine direkte Möglichkeit zu Messung der Leistungsaufnahme der an der Brücke angeschlossenen Geräte (z.B. Motoren).

\item[Low-Side-Switch]

Mit dem Siemens Smart Octal Low Side Switch TLE 6230 GP stehen über den SPI-Bus zwei Acht-Bit Schalter zur Verfügung.
Die Ansteuerung erfolgt über 2 $\times$ Acht-Bit Wörter, wobei das erste Wort der Konfiguration das zweite der Freischaltung dient.
Vier der Acht Anschlüsse sind PWM\footnote{PWM Puls Weit Modulation oder engl. Pulse Width Modulation}-bar. Die notwendigen Signale dazu gehen direkt
vom Microcontroller aus (also ohne den Umweg über den SPI-Bus).
Die Bausteine haben einen Kurzschlußschutz integriert.

\item[Digitale Eingänge]
Mit dem ULN2004A gibt es über 7 Anschlüsse einen direkten Zugang zum Microcontroller. 
Der sieben Darlington Schlatungen enthaltende Baustein von STMicroelectronics Akzeptiert eine Eingangsspannung von fünf bis zu acht Volt je nach
Eingangsstrom.
Drei der Eingänge werden an den interruptfähigen Port des Microcontrollers durchgeschaltet. Dadurch ergibt sich eine weitere Möglichkeit die Platine
von ausserhalb zu ,,wecken''.

\item[Brücken]
Für verbrauchsstarke Gleichstromgeräte sind zwei H-Brücken Der Firma Infineon auf der Platine enthalten. Der TLE 5206-2 kann bis zu 40 Volt Spannung bei
fünf Ampere liefern. Er verträgt dabei kurzzeitige Stromspitzen von bis zu sechs Ampere.
Die aus zwei Bausteinen resultierenden 4 Anschlüsse, können beispielsweise für vier in eine Richtung steuerbare Motoren oder zwei in beide Richtungen
steuerbare Motoren verwendet werden.

\item[Speicher]
Mit dem FM24C64 steht ein 64 Kilobyte großer seriell bedienbarer Speicher zur Verfügung. Der Speicher ist unterteilt in acht $\times$ 8.192 Bits,
so daß jeweils acht Bit seriell in den Speicher geschrieben werden können. Die Speicherzelle werden also mit einer 13-stelligen Binärzahl
adressiert$2^{13}$.

\item[LED]
Um ein optisches Feedback (zum Beispiel für den Fall einer Fehlfunktion) für den Programmierer zu ermöglichen, sind zwei LED\footnote{LED = Light Emitting
Diode} an den Microcontroller angeschlossen. Eine davon blau die andere grün.

\end{description}

Tabelle : anschlüsse input output stromaufnahme Spannungsaufnahme Gerät 

Tabelle : interne Komunikation mit Micocontroller Frequenz max anzahl wörter wortlänge

\newpage

\section{Anforderungen an die Implementierung des Microcontrollers}
Im folgenden werden die Auswirkungen der Vorgaben auf die Assembler-Programme des Microcontrollers beschrieben.

\subsection{Bedienbarkeit}
Was bedeutet Bedienbarkeit im Bezug auf die Programme des Microcontrollers?

Ziel ist es dem Entwickler eine Art Bibliothek zur Ansteuerung der einzelnen Platinenkomponenten anzubieten.
Folgende Punkte sind dabei mit Rücksicht auf die Assemblerumgebung weitestmöglich zu beachten:
\begin{itemize}
\item Die Programmpakete für die einzelnen Platinenkomponenten müssen als Module verfügbar sein, die gegebenenfalls vom Entwickler eingebunden werden
können.
\item Die einzelnen Module müssen sich den Arbeitsspeicher so teilen, das Keines das jeweils Andere stört bzw. Inkonsistenzen zur Laufzeit hervorruft.
Das heißt das eine strikte Arbeitsspeichernutzung vorhanden sein muss.

\item Es müssen Konventionen für den Austausch von Daten zwischen den Modulen entwickelt werden.

\item Der Programmspeicher muss möglichst effizient von den Modulen genutzt werden.

\item Innerhalb der Module sollte es keine weiten Verzweigungen durch Unterprogrammaufrufe geben, um dem Entwickler(und damit Nutzer der Module)
möglichst viel Freiraum auf dem Unterprogramm-Stapel gezu wewährleisten.

\item Konstante Einstellungen die sich aus der Architektur der Platine ergeben sollten dem Entwickler durch ,,sprechende'' Konstantennamen einfach
handhabbar gemacht werden.
\end{itemize}

\subsection{Sicherheit}
Die Implementierung der Platinen muss eventuelle Fehlfunktionen berücksichtigen und adäquat behandeln ohne die Kommunikationsebene zu stören.
Desweiteren muss es einen sicheren Zustand geben in den die Platine bei etwaiger Fehlfunktion versetzt wird um Kurzschluss, unnötigem Leistungsverbrauch
oder ähnlichem vorzubeugen.

\subsection{Kommunikation}

Die Modularität des Systems bringt eine Vielzahl von Kommunikationsanforderungen mit sich. So müssen die Einzelnen Platinen in Kontakt mit der
Steuereinheit treten, auf der Platine muss der reibungslose Austausch zwischen den Programmmodulen sichergestellt sein ohne inkonsistenzen
hervorzurufen, auf Hardwareebene werden einzelne Kompenenten über ein serielles Protokoll angesprochen (SPI) und nicht zuletzt muss der Microcontroller
die zeitkritische serielle Schnittstelle betreiben (sofern das Modul eingebunden ist).

\subsection{Erweiterbarkeit}
Um auch zukünftige Weiterentwicklungen der Peripherie berücksichtigen zu können, muss die Programmierung der Komponnenten einer klaren Konvention
folgen.So können auch neue Implemetierungen diesem Muster folgen und der Entwickler hat eine geringe Einarbeitungszeit. Eine Schnittstelle im Sinne
einer Hochsprache ist hier nicht von Nöten, da die geringe Stacktiefe und der begrenzte Programmspeicher ohnehin eine geringe
Verschachtelungstiefe der Unterprogramme erzwingen.

\newpage
\section{Implementierung}
\label{Implementierung}
\subsection{Programmierumgebung}
\label{Umgebung}

Wie bereits im vorangehenden Kapitel beschrieben war einer der Gründe für die Wahl des SX52 seine gute Handhabbarkeit bei der Entwicklung.
Dies hängt mit der erhältichen Entwicklungsumgebung der Firma Parallax zusammen. 
Das Programm SX52 besteht aus einem Editor einem Assembler-Interpreter und einem Laufzeitdebugprogramm. Um den Microcontroller zu programmieren
beziehungsweise die Debugroutinen anzuwenden, benötigt man ausserdem den SX-Key \ref{cr_sx_key}. Der SX-Key übernimmt so er angeschlossen ist die Taktung des
Prozessors, so das die Debugfunktionen möglich sind.

\begin{figure}
  \center
  \includegraphics[width=277pt]{sx-key_m.eps}
  \caption{Der SX-Key}
  \label{cr_sx_key}
\end{figure}

Die Debugfunktion ermöglicht die Ausführung von
Programmen schrittweise zu verfolgen und dabei die Registerinhalte zu überwachen. Desweiteren können bestimmte Register oder gar Bits formatiert (als binäre,
hexadezimale oder dezimale Zahl) angezeigt werden. 

\begin{figure}
  \center
  \includegraphics[width=400pt]{regs_dbug_500.eps}
  \caption{Registerfenster mit Debugleiste}
  \label{cr_sx_exe}
\end{figure}

\subsection{Funktionsweise eins SX52 Assemblerprogramms}
Im folgenden wird die Funktionsweise eines SX52 Assemblerprogramms grob umrissen, um eine Verständniss der folgenden Erklärungen zuermöglichen.
Ich gehe davon aus, das Begriffe wie Akkumulator,Clock (oder auch Zeitgeber) und Register bereits bekannt sind.

Die Programme des SX52 sind ein einem 64 Kilobyte grossem EEPROM untergebracht. Jedes Byte hat eine Länge von zwölf Bit. Ein Byte repräsentiert eine
Instruktion für den Microcontroller. Dabei teilt sich ein solches Byte je nach Befehl in Operationscode und Argumente. Anders als zum Beispiel bei
einmem MIPS Assembler haben die Operationscodes nicht alle die gleiche Länge. Die Adresse der aktuell auszuführende Zeile entnimmt man dem
Programmzähler (zu engl. Programm Counter, abgekürzt PC).

Ein Programm beginnt an der höchsten Stelle des Speichers, also an der Stelle FFF (Hexadezimal). Dort wird die Einsprungadresse des Hauptprogramms
eingelesen und in den Programmzähler geschrieben. Die Einsprungadresse wird auch als ,,\footnote{engl.reset: widerherstellen. In diesem Kontext soll
der Anfangszustand des Programms wieder hergestellt werden}reset'' bezeichnet. Der Befehl an der aktuellen Stelle wird eingelesen und, nach dem der Programmzähler um Eins iteriert
wurde, ausgewertet.

Ein solches Programm könnte nun bis zu höchsten Stelle durchlaufen und dann wieder von der Stelle FFF (hexadezimal) aus zurückspringen. In der Praxis wird das jedoch
selten so gehandhabt. Folgende Ereignisse können den Kreislauf unterbrechen:

\begin{description}
\item[Rollover-Interrupt]
Der \footnote{engl.roll over: überschlagen, vorne überkippen; engl. interrupt: die Unterbrechung}Rollover-Interrupt unterbricht das Programm, schreibt
den aktuellen Inhalt des Programmzählers, sowie den Akkumulator und die Register \footnote{FSR: File Select Register, enthält den Zeiger auf die
Aktuelle Registerbank}FSR und \footnote{}STATUS in ein eigens für die Interruptbehandlung vorgesehenes
Register. Danach werden die Befehle ab der Adresse 000 ausgeführt bis das Ende des Interrupts durch einen speziellen Rücksprungbefehl angezeigt wird (hier: RETIW
oder RETI). Diese Befehle sorgen nun dafür, dass der Programmzähler, der Akkumulator und die Register FSR und STATUS wieder auf die zuvor gespeicherten
werte gesetzt werden. Die Befehle von der Adresse 000 bis zum Rücksprungbefehl werden im folgenden als Interrupt-Routine bezeichnet.
Während eine Interrupt-Routine ausgeführt wird, kann kein weiterer Interrupt erfolgen.
\item[SLEEP-Befehl]
Durch den SLEEP-Befehl wird die Clock ausgeschltet und alle den Microcontroller betreffenden Systeme nur noch minimal versorgt. Das Programm hält an.
\item[Multi-Input-Wakeup-Interrupt]
Der Multi-Input-Wakeup-Interrupt wir durch ein Signal am Port B ausgelöst. Er bewirkt entweder das ,,aufwachen'' des Microcontrollers, wenn dieser im
SLEEP-Modus war, oder er startet die Interrupt-Routine.
\item[Endlosschleife]
Man kann das erreichen der höchste Speicherstelle auch durch eine eigene Endlosschleife verhindern, die während des Programmlaufes nicht verlassen
wird.
\item[Neustart durch ab- und einschalten der Versorgungsspannung]
Natürlich kann man den Microcontroller auch aus- und wieder anschalten um das Programm zu unterbrechen.
\end{description}

Während des Programmablaufes werden Daten eingelesen, bearbeitet und ausgegeben. Dies geschieht in den Registerbänken. Man Unterscheidet im Fall des
SX52 zwischen globalen und zu adressierenden Registerbänken zu je 16 Byte a acht Bit. Die globalen Register sind jederzeit adressierbar. Sie enthalten
unter anderen das STATUS-Register, das FSR-Register und die Port-Register. Im FSR ( engl. File Select Register, etwa Dateiauswahlregister) stehen die ersten vier Bit der zu
adressierenden Registerbank. Um eine Bank zu adressieren schreibt man entweder die entsprechende Adresse direkt in das FSR-Register oder nutzt den
BANK-Befehl gefolgt von einer drei Bit Nummer, das viert Bit im FSR wird dabei immer auf 0null gesetzt. Um jetz trotzdem die undgeraden Registerbänke
adressieren zu können muss der Programmierer das entsprechende Bit im FSR-Register setzten. Diese umständliche handhabe ist auf die Kompatibilität mit
dem SX32 zurückzuführen, der nur acht Registerbänke zur Verfügung stehen hat.

\subsubsection{Unterprogrammaufrufe}
Unterprogrammaufrufe werden mittels CALL-Befehl realisiert. Der SX52 enthält einen Stapel der Tiefe acht, um Unterprogramme rekursiv aufzurufen.
Beim Aufruf eines Unterprogramms wird die Rücksprungadresse auf den Stack gelegt und der Programmzähler auf den Wert des CALL-Arguments gesetzt.
Das Argument kann jedoch nur einen Adressraum von 256 Byte ansprechen (Argumentlänge: neun Bit), drei der restlichen vier Bit für eine vollständige
Programmspeicheradresse stehen im STATUS Register das vierte Bit wird auf null gesetzt. Für die Programmierung bedeutet dies, das mit einem
Unterprogrammaufruf innerhalb einer Programmspeicherseite nur Unterprogramme in der unteren Hälfte aufgerufen werden können. Weiter unten im Text wird
ein Konzept beschrieben, das diese Einschränkung geschickt umgeht.

\subsubsection{Arbeitsregister}
Der SX52 nutzt in der Summe 17 Register zur Verarbeitung von Daten zur Laufzeit. Die Register teilen sich auf in eine globale Bank und 16 indirekt 
adressierbare Bänke. Jede Bank enthält 16 Register. Für die Adressierung der globalen Register sind keine Vorkehrungen nötig. Um die 16 ,,normalen''
Registerbänke zu referenzieren schreibt man einfach die Registernummer hin. Die globale Register haben in den vier \footnote{Most Significent Bits:
Höchstwertigen Bits}MSB einen ungeraden Wert stehen, während für die ,,normalen'' Register immer ein gerader Wert in den ersten vier Bit steht.
Steht alo im Bit Nummer vier des Befehlsarguments eine Eins, so werden die Bits 0 bis 3 für die Adressierung eines globalen Registers genutzt, sonst 
wird ein Register aus der im FSR spezifizierten Bank entnommen.
Beispiel:
\begin{verbatim}
; W bezeichnet den Akkumulator
MOV  \$1A,W ; schreibt den Inhalt von W in das globale register \$1A
BANK \$60   ; stellt FSR auf Bank sechs
SETB FSR.4 ; stellt FSR auf Bank sieben
MOV  \$0A,W ; schreibtden Inhalt von W in das register Nr.\$7A
\end{verbatim}
In der Summe stehen dem Benutzer 256 Register plus 15 globale Register zur Verfügung. Von den globalen Registern sind die ersten fünf Register für
spezielle Aufgaben vorgesehen (unter anderen FSR und STATUS-Register),dann folgen die fünf I/O-Ports die auch als Register nutzbar sind, und dann
bleiben noch sechs ,,freie'' Register.

\begin{figure}
  \center
  \includegraphics[width=400pt]{register.eps}
  \caption{Aufbau der Registerbänke im SX52}
  \label{register}
\end{figure}

\section{Assembler-Directiven}

Der zum SX52 gelieferte Assembler stellt eine Reihe von Direktiven zur Verfügung, die, klug genutzt, die Programmierung vereinfachen.
Eine Dirktive wird nicht zur Laufzeit, sondern bereits vor der Programmierung des Programmspeichers ausgeführt. sie dienen zum Beispiel zur
organisation des Programmcodes, zur Benennung von Variablen und Konstanten, oder zur arithmetischen Überprüfung einiger Programmkomponenten.
Im folgenden werden einige der Direktiven beschrieben und wie sie genutzt werden können um die Zielsetzungen in der Implementierung zu verfolgen.

\subsubsection{EQU-Direktive}
Mit der EQU-Direktive werden Konstanten oder Registern Namen zugeordnet.
\begin{verbatim}
LED	EQU 	RB.5        ; sechstes Bit auf Port B wird mit LED benannt
FOO	EQU 	\$0a         ; das Register 0a wird mit FOO benannt
BAR	EQU 	#%0000_0011 ; die Konstante BAR hat den Wert drei
\end{verbatim}
\subsubsection{ORG-Direktive}
Die ORG-Direktive dient der genauen Platzierung von Programmcode im Programmspeicher. Man definiert eine Speicheradresse zwischen 000 und FFF 
(hexadezimal) an welcher der folgende Programmcode beginnen soll.
\begin{verbatim}
ORG  #000	;der folgende Code wird ab Adresse 000 eingefügt
# Es folgt die Interrupt-Routine
...

ORG  #200	;der folgende Code steht ab Adresse 200 (hex)
CALL FOO	
MOV  \$01, #2	
...
\end{verbatim}
\subsubsection{DS-Direktive}
Die DS-Direktive benennt einen Programmspeicherbereich. Die größe des Bereichs in Byte wird als Argumnet übergeben.
\begin{verbatim}
FOO	DS	1
BAR	DS	2
\end{verbatim}
\subsubsection{MACRO-Direktive}
Ein nützliches Werkzeug bei der Speicherorganisation ist die MACRO-Direktive. Programmcode, der in ein Macro eingebunden wird lässt sich leicht aus dem
Programm entfernen und wieder einsetzen. Diese Eigenschaft ermöglicht es Programmteile genau zu platzieren und so Adressierungsbeschränkungen zu
umgehen.
\begin{verbatim}
MACRO 	FOO	; Macro namens FOO

MOV	M,#BAR	; Programmcode

ENDM
.
.
.
ORG	200
FOO		; Macro FOO wird bei 200 (hex) eingefügt
\end{verbatim}
\subsubsection{\$-Direktive}
Das Dollarzeichen liefert die aktuelle Bank zurück.
\begin{verbatim}
FOO EQU \$	;FOO enthält die aktuelle Bank
\end{verbatim}
\subsection{Konzeption}
\label{Konzeption}
Bei der Konzeption der Module galt es die potentiellen Schwierigkeiten mit Unterprogrammaufruf, Verteilung der Programmteile auf den Speicher, sowie
den Zugriff auf Register für den Entwickler möglichst einfach handhabbar zu machen.
Um dies zu erreichen eignet sich eine Modulstruktur die durch geschicktes Einsetzen der Macro-Direktiven die oben genannten Schwierigkeiten umgeht.
\subsubsection{Modulstruktur}
Man unterteilt jedes Modul in verschiedene Segmente. Begreift man nun ein Assemblerprogramm als Automat mit den Zuständen Initialisierung,
Hauptfunktion und Interrupt, so werden die einzelnen Segmente an der passenden Stelle eingebunden.
\begin{figure}
  \center
  \includegraphics[width=400pt]{Automat.eps}
  \caption{Ein Assemblerprogramm als Automat}
  \label{Automat}
\end{figure}
Zusätzlich Bedarf es für die Datenorganisation
noch ein CALL- und ein DATA-Segment. Im folgenden die Segmente im Einzelnen.
\begin{description}
\item[CODE-Segment]
Im CODE-Segment befinden sich die eigentlichen Routinen eines Moduls. Jede Routine beginnt dabei mit einer Einsprungmarke und endet mit einem
Rücksprungbefehl für Unterprogramme. Der Rücksprungbefehl setzt die durch einen CALL-Befehl gespeicherten Werte in STATUS-, FSR-Register und
Programmzähler wieder ein, und führt das Programm von dort an weiter aus.
\item[CALL-Segment]
Das Callsegmnet dient dazu die 256-Byte Grenze des CALL-Befehls zu umgehen. Dieses Segment muss jeweils in den unteren 256-Byte einer
Programmspeicherseite liegen.
Im CALL-Segment werden Funktionsnamen mit den entsprechenden Funktionen im CODE-Segment verknüpft. Der Trick liegt dabei in der verwendung des
JMP-Befehls. JMP springt an die im Argument übergebene Stelle in Programmspeicher. Da das Argument des JMP-Befehls neun Bit lang ist, können die vollen
512 Byte eine Speicherseite referenzeiert werden.
Das CALL-Segment ermöglicht also einen Unterprogrammaufruf ohne die 256-Byte Beschränkung bedenken zu müssen. Desweiteren fügt der Assembler noch einen
PAGE-Befehl ein wenn dem CALL ein @ vorangestellt wird, so dass auch dies Beschränkung wegfällt.
\item[DATA-Segment]
Wie bereits oben beschrieben stehen dem Programmierer 256 Register auf verschiedenen Bänken zur Verfügung. Um mit den Registeradressierungen nicht
durcheinander zu kommen, empfiehlt es sich pro Modul nur auf einer Bank zu arbeiten, die dann ausschließlich dafür reserviert ist.
Die Macros ermöglichen es bei der Programmierung auf Register Adressierung zu verzichten.
Um das zu erreichen definiert man ein Macro in dem platz für maximal 16 Register reseviert wird. Man benutzt bei der Programmierung dann nur noch die
Variablen für den reservierten Platz. Diese Praxis ist mit der Variablendeklaration in einer Hochsprache vergleichbar, nur das die Typisierung vom
Benutzer und nicht vom Compiler vorgenommen wird.

Um dann die entsprechende Bank zu reservieren, Wird das Macro durch die ORG Direktive an der entsprechenden Stelle eingefügt. Die erste Instruktion im
Macro weist dann einer Variablen die aktuelle Adresse zu, so daß der Entwickler mit der Kombination BANK-Befehl und eben genannte Variablen die
entsprechende Modulbank referenzieren ohne schon wissen zu müssen welche Bank er eigentlich nutzt.
Beipiel
\begin{verbatim}
MACRO 	  FOO	; Macro namens FOO
MEINEBANK \$     ; Die aktuelle Bank wird referenziert
VAR1      DS1   ; Ein Register reservieren
VAR2      DS1   ; ...
...
ENDM

ORG	\$20
FOO		; Macro FOO wird bei 20 (hex) eingefügt
                ; enspricht der dritten Bank
\end{verbatim}
\item[INTERRUPT-Segment]
Benötigt man für ein Modul auch Routinen die durch einen Interrupt ausgelöst werden, so schreibt man den dazu nötigen Code in ein Macro.
Dieses Macro wird als Interrupt-Segment beschrieben. Die Interrupsegmente schreibt man dann hintereinander an die Adresse 000 (hexadezimal). In den
Interruptsegmenten darf kein Interrupt Rücksprungbefehl stehen. Der muss am Ende der Macroliste stehen um sicherzustellen das alle Segmente ausgeführt
werden.
\item[INIT-Segment]
Jedes Modul benötigt auch einen Bereich im Initialbereich des Gesamtprogramms zur Initalisierung seiner Variablen. Dazu definiert man zu jedem Modul
ein INIT-Macro. 
\end{description}
Zusammengefasst könnte ein Programm nach den oben beschriebenen Konventionen dann wie folgt aussehen:
\small{
\begin{verbatim}
;M O D U L E
; Modul_1

; DATASEGMENT
    MACRO   DATA_MODUL_1
     MEINEBANK \$     ; Die aktuelle Bank wird referenziert
     VAR1      DS1   ; Ein Register reservieren
     VAR2      DS1   ; ...
    ENDM
    
; INTERRUPTSEGMENT
    MACRO   INTERR_MODUL_1
    ;Anweisungen die bei Interrupt ausgeführt werden sollen
    ENDM
    
; INITSEGMENT
    MACRO   INIT_MODUL_1
    ;Initialisierung der Variablen
    ENDM
    
; CALLSEGMENT
    MACRO   CALL_MODUL_1
     routine_1
     JMP _routine_1 
    ENDM
    
; CODESEGMENT
   MACRO   CODE_MODUL_1
   _routine_1 ;Sprungmarke für CALL-Segment
   ; der eigenliche Code
   ...
   ENDM

; Modul_2
...
; CALLSEGMENT
    MACRO   CALL_MODUL_2
     routine_2
     JMP _routine_2
    ENDM
    
; CODESEGMENT
   MACRO   CODE_MODUL_2
   _routine_2 ;Sprungmarke für CALL-Segment
   ; der eigenliche Code
   ...
   ENDM
...
; Modul_3
...

;P R O G R A M M
Hier wird jetzt der Programmcode auf den Speicher verteilt

ORG \$000
;Interrupt
INTERR_MODUL_1
INTERR_MODUL_2
INTERR_MODUL_3
RETI ;aus Interrupt herausspringen

ORG \$500 
main        ;anfängliche Einsprungmarke
;Initialisierung
;Interrupt abschalten
...
;allgemeine Konfiguration
...
INIT_MODUL_1
INIT_MODUL_2
INIT_MODUL_3
;Interrupt wieder einschalten
mainprog   ; Hauptteil des Programms
...
@CALL routine_1
...
@CALL routine_2
...
JMP mainprog

ORG \$600
CALL_MODUL_1
CALL_MODUL_2
CODE_MODUL_1
CODE_MODUL_2

ORG \$800
CALL_MODUL_3
CODE_MODUL_3

\end{verbatim}
}
\subsubsection{Datenaustausch zwischen den Modulen}

Um den Austausch von Daten sicher zu stellen, werden zwei Bänke für den Austausch von Daten reserviert. Jedes Modul entnimmt dort seine Eingabewerte und
 legt die Ergebnisse dort wieder ab.

\subsection{Implemetierungen}
Im folgenden werden beispielhaft Module für einige Bauelemente beschrieben.

\begin{description}
\item[Serielle Schnittstelle]
Die serielle Datenübertragung ist in der Norm RS232 festgelegt.
Danach können zwei Computer über die Datenleitungen TxD (Transmit Data) und RxD (Receive Data) miteinander kommunizieren.
Ein Byte wird im 8n1 Modus gesendet. Das heißt es werden acht Bits digital gesendet. Zusätzlich wird jedem Datenbyte ein Startbit voran-
und ein Stopbit nachgestellt. Eine Fehlerüberprüfung (Parity) findet bei der Implementierung in diesem Fall nicht statt.
Es handelt sich bei der RS232 um eine asysnchrone Übertragung die,
im Gegensatz zur synchronen Übertragung, ohne separates Taktsignal erfolgt.
Ein Empfänger muß das eintreffende Signal mit einer mehrfachen Taktferquenz abtasten 
und so das Taktsignal rückgewinnen. Das setzt ein akkurates Timing voraus.
Um sicherzustellen, das eine Zustandsänderung am Eingang registriert wird, nimmt man als Abtastrate das vierfache der Zielfrequenz ab.
Um beispielsweise bei einer Zielfrequenz F von 115.200 Baud eine Änderung der eingehenden Flanke festzustellen, wird der Eingangszustand 
mit 460,8 kHz abgetastet.
Um ein genaues Timing zu realisieren nutzt die Implementierung den Rollover Interrupt. Der Rollover Interrupt löst alle 256 Zyklen
einen Interrupt aus. Dies entspricht bei einer Taktfrequenz $T$ von 50 Mhz einem Takt von 195.312,5 Hz.
reduziert man nun die Anzahl der Zyklen bis zum nächsten Interrupt, so lässt sich die Interrupt-Frequenz regulieren. Der
Befehl RETIW macht das möglich. RETIW setzt den Interruptzähler auf den im Akkumulator W übergebenen Wert.
So lässt sich mit 108 Zyklen pro Interrupt ein Takt von ungefär 115.200 Baud realisieren (vierfache Abtastrate).
In diesem Beispiel wird davon ausgegangen, das im interrupt keine weiteren Verzögerungen auftreten. Wenn jedoch mehrere Module mit
Interrupt-Segmenten genutzt werden, so muss die Verzögerung beim setzen des neuen Rollover Interrupt berücksichtigt werden.
Für eine Anzahl $n$ von Zyklen ergibt sich der zu übergebende Wert $w$ für der Akkumulator wie folgt:

\begin{displaymath}
w = \left\lfloor \frac{T}{4*F} \right\rfloor - n
\end{displaymath}
mit \begin{math}w \gg 0\end{math}.

\begin{math}w \gg 0\end{math} deutet darauf hin das dei Interruptroutine nicht zu groß ausfallen sollte, da sonst die Ausführung sonstiger
Programme zu kurz kommt.
Nutzt man also das Modul, so muss zuvor eine Baudrate für die serielle Übertragung festgelegt werden, und im Interrupt-Segment eingetragen
werden. Für die Platine ist eine Baudrate größer als 115.200 nicht empfehlenswert, da sonst die eigentlichen Programmteile nicht mehr
ausreichend zur Ausführung kommen.
\item[Puls Weit Modulation]
Mittels Puls-Weit-Modulation läßt sich an digital angeteuerten geräten analogen Verhalten erzeugen.
Dabei wird die Trägheit der jeweiligen elektromechanischen Gerätes augenutzt um die digitalen Impulse zu einer monoton steigenden Funktion zu
,,wandeln''. 
Man unterteilt ein Zeitintervall $I$ äquidistant in $n$ kleinere Zeitintervalle $z_{i}$ mit $i = 0,...,n$. 
Geht man davon aus das ein Ausgang zwei Zustände $low$ und $high$ einnehmen kann, und das jedes Zeitintervall $z_{i}$ mit dem Zustand
$low$ beginnt. In jedem Zeitintervall $z_{i}$ wählt man dann ein $t_{i}$ mit $0 < t_{i} < |z_{i}|$ ab welchem der Wert des Ausgangs
auf $high$ geht.
Die Grösse $t_{i}$ bestimmt dann die Intensität mit der das am Ausgang angeschlossene Gerät betrieben wird. Im folgenden wird $t_{i}$
auch Pulsweite genannt.
Ein angeschlossener Gleichstromotor zum Beispiel dreht sich bei $t_{i} = 1/2 z_{i}$ nur halb so schnell als normal.
Ändert man nun $t_{i}$ in die eine oder andere Richtung, so erzeugt man Dim-effekte.
Ein Beispiel ist die Funktion $t_{i}=i*z_{i}/n$, die $t-{i}$ mit jedem Schritt an $n$ annähert und damit von $low$ nach $high$
übergeht (siehe dazu \ref{cr_pwm}).

Auf die Platine sind die Brücken und die PWM-baren Low-Side-Switchs für die Puls Weit Modulation vorgesehen.
Ein $z_{i}$ entspricht 256 Interrups. In jedem Interrupt wird ein Zähler iterriert bis dieser überläuft. Bei jedem Übelauf wird der
Zustand auf $low$ bzw $high$ gesetzt (je nachdem ob von Aus nach An oder umgekehrt moduliert wird). Im Hauptprogramm (CODE-Segment)
wird dann der Zähler mit einer Variable verglichen die dei Pulsweite bestimmt. Je nach Anwendung kann man nun die Pulsweite veändern,
indem man sie iterriert oder decrementiert bzw. unterschiedlich initialisiert.
%reverse iterations
\begin{figure}
  \center
  \includegraphics[width=400pt]{pwm.eps}
  \caption{Puls Weit Modulation einer linearen Funktion}
  \label{cr_pwm}
\end{figure}

\item[SPI]
Um eines der Geräte über den SPI-Bus zu adressieren muss das betreffende Gerät per Chip-Select aktiviert werden.
Wie in \ref{cr_SPI-Bus} beschrieben erfolgt die Aktivierung der einzelnen Geräte über einen Multiplexer der über die Pins 
drei bis fünf am Port D an den SX52 angeschlossen ist.
Die folgenden Konstanten repräsentieren die Pinbelegungen des Port D für die einzelnen Geräte:
\begin{verbatim}
SPI\_TLE1		EQU \%0000_0000 ; Low-Side-Switch
SPI\_TLE2		EQU \%0000_1000 ; Low-Side-Switch
SPI\_ADC			EQU \%0001_0000 ; Analog-Digital-Wandler
SPI\_DAC			EQU \%0001_1000 ; Digital-Analog-Wandler
SPI\_CAN			EQU \%0010_0000 ; CAN-Controller
SPI\_RESET		EQU \%0010_1000 ; RESET aller RESET-fähigen Geräte
SPI\_NOTCON		EQU \%0011_0000 ; zu keinem Gerät verbunden
\end{verbatim}
Das Bitmuster SPI\_NOTCON kann genutzt werden um mit Sicherheit kein Gerät anzuwählen, so das man bei der Programmierung nicht auf die
Pinbelegungen auf Port D achten zu müssen.
Wenn das Gerät ausgewählt ist, erfolgt Gerätespeziefisch die Übertragung verschiedener Bitmuster.
Im Detail werden die geräte wie folgt behandelt:
\begin{description}
\item{TLE}2 x 12 Bit
\item{ADC}4 Bit CS 
\item{DAC}12 Bit
\item{CAN}siehe dazu Kapitel \ref{jameson_kapitel}.
\end{description}
\end{description}
\newpage
\section{Fazit}
Die Wahl des Microcontrollers hat sich als gut erwiesen, da sich eine gut handhabbare Programmstruktur erstellen lies. Das dies nicht nur aus der
Sicht eines Informatikers gilt, hat die Schulung des Münchner Projektteams im Mai 2002 gezeigt. Auch in Zukunft wird die Platine dort in anderen
mechatronischen Projekten genutzt werden. Ebenso hat die Arbeit gezeigt wie wichtig der Austausch zwischen den Teammitgliedern und den
beteiligten Disziplinen für eine adäquate Anforderungslösung ist.
\section{Ausblick}
Die Grundlagen für die Nutzung der Platine ist erfolgt. Um die Nutzung noch komfortabler zu gestalten ist es wünschenswert eine
didaktisch sinnvolle schriftliche Anleitung zu schaffen. Darüber hinaus ist eine ausführliche Technische Dokumentation brauchbar.
Während meiner Recherchen für Beispielprogramme stieß ich auch auf einen C-Compiler für den SX52. Würde man nun eine grafische Oberfläche
zur Nutzung der Module mit dem C-Kompiler verbinden, könnte man eine komplette und komfortable Mechatronik-Entwicklungsumgebung als
Produkt anbieten. Insbesondere in Bildungsbereich könnte dies Anklang finden.
%Anleitung
%C-Compiler
%Techn Docu
