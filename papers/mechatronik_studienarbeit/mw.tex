\section{Aufgabenstellung}

Abbildung \ref{mw_seite} zeigt eine Seitenansicht des Läufers.  Dabei
wurden die derzeit geplanten mechatronischen Komponenten markiert.\\
Die einzelnen Komponenten sind:

\begin{figure}
  \center
  \includegraphics[width=13.5cm]{mw/bilder/seitenansicht.eps}
  \caption{Seitenansicht des Läufers mit Markierungen der
    Mechatronischen Komponenten}
  \label{mw_seite}
\end{figure}

\begin{enumerate}
\item
  Antriebsstrang
\item
  Beleuchtungssystem 
\item
  Fahrerinformations-System
\item
  Ständer
\end{enumerate}

Für die Zukunft sind weitere Komponenten möglich und auch eingeplant.
Konkret angedacht wurde z.B. eine Anbindung eines GPS\footnote{Global
Positioning System}-Systems über den CAN\footnote{Controller Area
Network, vgl. Kapitel \ref{jameson_kapitel}}-Bus.  Die mechatronischen
Komponenten des Läufers verfügen über etliche Parameter, die der
Fahrer beeinflussen möchte.  Als Beispiel sei hier der Antriebsstrang
genannt.  Es soll dem Fahrer z.B. ermöglicht werden, bei vollen
Batterien und kurzer Strecke alleine elektrisch zu fahren, und die
Pedale ohne Widerstand zu benutzen.

Außerdem gibt es Informationen über den aktuellen Zustand des
Fahrzeuges, die an den Fahrer weitergeleitet werden müssen.  Dies sind
zum einen Daten, wie man Sie auch vom normalen PKW kennt, wie z.B. die
aktuelle Geschwindigkeit, zum anderen kommen beim Läufer spezielle
Informationen aus dem Antriebsstrang hinzu: Wie schnell kann man bei der
aktuell in den Pedalen abgegebenen Energie fahren? Oder, wie voll sind
die Batterien?  Die beschriebenen Informationen müssen dem Fahrer in
einer Art und Weise zur Verfügung gestellt werden können, die der
Fahrsituation angemessen ist.

Zusätzlich ergaben Gespräche mit den Entwicklern mechatronischer
Komponenten, daß aufwendige Berechnungen, die sich aus den Wünschen
des Fahrers ergeben, in einer relativ komfortablen Hochsprache wie
C/C++ programmierbar sein sollten, anstatt vergleichsweise umständlich
in Assembler auf den Embedded Platinen.

Es ergeben sich somit die folgenden Anforderungen an das
Fahrerinformationssystem des Läufers:

\begin{description}
\item[Genügend Rechenleistung:] Die geforderten Berechnungen sollen
  komfortabel in Hochsprachen durchgeführt werden können.
\item[Display:] Die Informationen für den Fahrer müssen dargestellt
  werden.  Aufgabe des Displays ist es, das Armaturenbrett eines PKW
  zu ersetzen.
\item[Interaktion:] Um die teilweise sehr umfassenden
  Einstellungsmöglichkeiten des Fahrzeugs ausnutzen zu können.
\end{description}

Die beschriebenen Aufgaben lassen sich in hervorragender Weise von
aktuellen Taschencomputern, sogenannten PDAs\footnote{PDA: Personal
Digital Assistent, zu Deutsch etwa: Persönlicher Digitaler Assistent.}
erfüllen. Exemplare der Gerätekategorie PDA, insbesondere die neuerer
Bauart, verfügen über genügend Rechenleistung, um die Aufgaben
innerhalb des Läufers bewältigen zu können.  Zusätzlich sind sind die
mobilen Kleicnrechner sehr stark auf den sorgsamen Umgang mit Energie
optimiert, was in einem Fahrzeug, daß seine Energie ausschließlich aus
der Muskelkraft seiner Fahrer bezieht, natürlich von besonderem
Interesse ist.  Außerdem sind sie in großen Stückzahlen kommerziell
verfügbar, was den Preis für den einzelnen PDA stetig sinken läßt.

Aufgabe im Bereich des Fahrerinformationssystems ist es also
einerseits, einen geeigneten PDA auszuwählen und den gewählten
andererseits durch das Erstellen zusätzlicher Software für das Projekt
nutzbar zu machen.

Die zu erstellende Software ist vor allem ein Kommunikationssystem
zwischen PDA und den im Fahrzeug verteilten Komponenten.  Dies ist
nötig, da im PDA-Bereich zwar die aus dem PC-Markt bekannten
Schnittstellen und Kommunikationsprotokolle zur Verfügung
stehen\footnote{Beispiele hierfür sind die serielle Schnittstelle, die
Infrarottechnik IrDA sowie USB}. Im Bereich der mechatronischen
Systeme stehen die aus der PC-Technik stammenden Schnittstellen jedoch
im Allgemeinen nicht zur Verfügung.  Vielmehr dominieren Protokolle
wie CAN und SPI\footnote{siehe Kapitel \ref{cr_kapitel}}.

Für den Entwicker einer mechatronischen Komponente für den Läufer muß
die Kommunikation möglichst einfach zu handhaben sein.  Eine solche
Forderung ergibt sich aus den Überlegungen in Kapitel
\ref{mw_problem}. Die entwickelte Software muß diesem Umstand Rechnung
tragen, indem sie dem Entwickler eine möglichst einfache und intuitive
Programmierschnittstelle zur Verfügung stellt.

Neben den bisher erläuterten Anforderungen der Entwickler
mechatronischer Komponenten soll aber gerade bei der Auswahl des PDAs
der spätere Nutzer des Läufers und seine Wünsche Berücksichtigung
finden. Der potentielle Läuferfahrer bzw. die potentielle Fahrerin
wünscht sich von einem solchen Gerät einen Mehrfachnutzen.  Es soll
also sowohl als ,,Bordcomputer'' des Läufers fungieren können, als
auch ein vollwertiger PDA sein.

Im folgenden soll zunächst die Entscheidung für einen speziellen PDA
transparent gemacht werden.  Daraufhin wird die
Kommunikations\-schnittstelle für die Entwickler mechatronischer
Komponenten für den Läufer beschrieben.

Im Bereich der Projektarbeit ergeben sich natürlich auch
Anforderungen, die sich nicht direkt aus theoretischen Erwägungen
ableiten lassen können.  Viele Anforderungen werden erst und immer
wieder im Gespräch mit den Projektteilnehmern aus anderen
Fachgebieten, wie z.B. dem Maschinenbau oder dem Industriedesign,
deutlich.  Ergebnisse dieser Anforderungen sind unter anderem der so
genannte DebugTreiber, auf den am Ende des aktuellen Kapitels
exemplarisch für die interdisziplinäre Zusammenarbeit innerhalb des
Projektes eingegangen werden soll.


\newpage
\section{Auswahl des PDA}
\subsection{Anforderungen}
Die Anforderungen an den PDA ergeben sich aus den Anforderungen an die
gesamte Mechatronik sowie an das Fahrerinformationssystem im
speziellen.  Sie lassen sich in Anforderungen an die PDA
Systemsoftware und Anforderungen an die PDA-Hardware gliedern, was im
folgenden geschehen soll.  Eine Gliederung nach Betriebssystem ist
hilfreich, da sich auch der PDA-Markt sehr gut nach der Systemsoftware
der PDAs unterteilen läßt.  Weiter unten wird dies zur Vorauswahl des
PDAs ausgenutzt.

\subsubsection{Anforderungen an die Software}
\begin{description}
\item[Multitasking:] Hierbei verstehen wir unter ,,Multitasking'' die
  Fähigkeit des PDA, mehrere Programme unabhängig voneinander
  auszuführen.  Die Anforderung nach Multitasking ergibt sich
  unmittelbar aus der Forderung an die gesamte Mechatronik,
  erweiterbar zu sein.  Ein PDA ohne Multitasking würde allerdings bei
  jeder Erweiterung des Systems einen Eingriff in die
  sicherheitsrelevante Fahrsoftware des Läufers erfordern, was z.B.
  beim Einfügen eines GPS\footnote{GPS=Global Positioning System}
  basierten Navigationssystems nicht wünschenswert ist.  Verfügt der
  PDA hingegen über Multitasking, kann eine Erweiterung auch durch ein
  weiteres Programm geschehen, daß parallel zu den anderen läuft.
  
\item[GUI-Flexibilität:] Das Projekt Läufer geht in vielen Bereichen
  einen designorientierten Weg, der nicht unerheblich zu dem großen
  Erfolg des Läufers in der Öffentlichkeit sowie beim Aufbau von
  Industrie-Partnerschaften beigetragen hat.  Auch im Bereich der
  graphischen Interaktion mit dem System soll ein designorientierte
  Weg möglich sein, um den Läufer als ,,rundes Produkt'' entwickeln zu
  können.
  
  Bei der Auswahl eines PDA samt zugehöriger Software ist demgemäß
  darauf zu achten, daß man im Bereich der Gestaltung des
  GUI\footnote{GUI=Graphical User Interface, zu Deutsch: Graphische
    Benutzer Schnittstelle} grösst\-mögliche Freiheiten hat.
  
\item[Programmierung:] Die Programmierung des PDA sollte einfach sein,
  wobei mit ,,einfach'' im Kontext des Läufers gemeint ist, daß die
  Entwicklung für den PDA sich möglichst wenig von der Entwicklung für
  einen PC unterscheiden sollte.  Das ist sinnvoll und wünschenswert,
  da die späteren Nutzer unserer Software wahrscheinlich schon über
  Erfahrungen in der Programmierung von PCs verfügen und deren
  Lernaufwand ja so niedrig wie möglich zu halten ist.
  
  Außerdem ermöglicht eine solche Vorgehensweise idealerweise die
  Entwicklung der Software auf einem PC, um sie dann später ohne große
  Umstände einfach auf den PDA übertragen zu können.  Inbesondere vor
  dem Projekthintergrund und der verteilten Produktentwicklung kann
  ein so ausgelegtes Vorgehen erhebliche Kosten für die Beschaffung
  von PDAs für die einzelnen Entwicklerteams in Darmstadt und München
  einsparen.
  
\item[Dokumentation und Support:] Da die Entwicklung der Software über
  die vorliegende Studienarbeit hinaus von weiteren Entwicklern
  fortgesetzt werden soll, ist eine gute Dokumentation und ein
  umfassender Support der verwendeten Werkzeuge, Bibliotheken und
  Compiler mehr als wünschenswert.
  
  Aus den selben Gründen ist es nötig, auf eine möglichst
  ,,langlebige'' Plattform zu setzen, die sich nicht innerhalb des
  Projektes ständig verändert oder für deren eingesetzte Version man
  in Zukunft womöglich keine Entwicklungstools mehr erwerben kann.
  
\end{description}


\subsubsection{Anforderungen an die Hardware}
An die Hardware eines PDA für den Einsatz in einem Fahrzeug stellen
sich besondere Anforderungen, die im folgenden erläutert werden
sollen.

\begin{description}
\item[Display:] Beim Display eines PDA für den Einsatz im Läufer gibt
  es zwei wesentliche Aspekte zu beachten: Zum einen sollte es sich um
  ein Farbdisplay handeln und zum anderen sollte es vor allem unter
  all den Lichtbedingungen, in denen der Läufer unterwegs sein wird,
  gut ablesbar sein.
  
  Die Forderung nach einem Farbdisplay ergibt sich aus der
  Design-Orientierung des Projektes sowie der Anforderung nach
  GUI-Flexibilität.  Desweiteren spricht für ein Farbdisplay,daß man
  mit ihm Warnhinweise und normale Nachrichten des Systems auf dem
  Display farblich kodieren kann, wie man dies von anderen Geräten
  kennt.  So lassen sich durch Farbe gerade im Fahrbetrieb wichtige
  Informationen hervorheben, was z.B. beim PKW mit seinen \emph{roten}
  Warnleuchten ebenfalls geschieht.
  
  Die Anzeigeeigenschaften des Display bei sehr extremen
  Lichtverhältnissen sind für den Läufer entscheidend.  Das Display
  muß bei allen Fahrsituationen möglichst gut ablesbar sein, um den
  Fahrer über den aktuellen Zustand seines Fahrzeuges zu informieren.
  Zu den kritischen Lichtverhältnissen gehört dabei weniger die Nacht,
  da alle modernen PDAs über eine leistungsfähige Beleuchtung
  verfügen.  Wesentlich wichtiger ist das Verhalten während der
  Dämmerung und bei starkem Sonnenschein.  Beides stellt einige
  Display-Konzepte bei heute marktüblichen PDAs vor große Probleme.
  
  Als Beispiel sei hier die inverse Hintergrundbeleuchtung der PDAs
  des Herstellers Palm genannt, die zwar bei absoluter Dunkelheit
  hervorragende Dienste leistet, bei Dämmerung aber zu Unlesbarkeit
  des Displays führt.
  
\item[Optik:] Ein ebenfalls nicht zu unterschätzender, wenn auch nur
  subjektiv zu beurteilender, Bereich ist die optische Erscheinung des
  PDA.  Die Optik spielt aus technischer Sicht natürlich nur eine
  untergeordnete Rolle, wird jedoch im Projektkontext bedeutsam.
  Erkennen lässt sich die Bedeutung des Designs für den Läufer an dem
  Umstand, dass einige Elemente des Läufers nur unter ästhetischen
  Gesichtspunkten zu Stande gekommen sind.  Da sich unsere Arbeit in
  das Projekt integriert, müssen wir dem Gesichtspunkt Optik ebenfalls
  Bedeutung zumessen.
  
  Ein objektiv nachprüfbarer Bereich der Optik ist die Bauform.  Für
  den Einsatz im Läufer kommen nur sogenannte Stift-PDAs in Frage, bei
  denen das Display hochkant steht und die Eingabe über einen Stift
  erfolgt.  Unter den bekannten um am Markt vertretenen Bauformen läßt
  sich ein Hochkant-Design am besten in das Fahrzeug-Cockpit des
  Läufers integrieren.
  
\item[Anschlußmöglichkeiten:] Da das Projekt Läufer eines mit
  ausser\-gewöhnlicher Dynamik ist, ist die Anschlussvielfalt an einem
  PDA im Läufer ein wesentliches Argument, um sich spätere
  Erweiterungen nicht durch einen zu beschränkten PDA zu verbauen.
  
  Die Mindestanforderung im Schnittstellen-Bereich ist eine
  RS232\footnote{Im PC-Bereich auch häufig nur ,,serielle
    Schnittstelle'' genannt.}  Schnittstelle, da über die serielle
  Schnittstelle die Verbindung zu einer unserer Platinen hergestellt
  wird.  Die Platine am anderen Ende der RS232-Schinttstelle verbindet
  dann den PDA mit dem CAN-Bus. Zu Details der Kommunikation im Läufer
  siehe Kapitel \ref{jameson_kapitel}.
\end{description}


\subsection{Auswahl der Systemsoftware}
Der PDA Markt läßt sich, wenn man die diversen geschlossenen Systeme
außer Acht läßt, nach den Betriebssystemen PalmOS, WindowsCE und
Linux aufgliedern.  Die ebenfalls noch angebotenen PDAs der Firma
PSION finden hier keine Beachtung, da deren Vermarktung und
Weiterentwicklung mittlerweile eingestellt wurde.  Außerdem paßt
deren Tastatur-Orientiertes Design nicht in das Konzept des
Cockpit-Entwurfs für den Läufer.

Die Einteilung nach Betriebssystem lieferte eine erste Kategorisierung
des PDA-Marktes.  Zu jedem System sind relativ viele verschiedene PDAs
am Markt, wordurch die Entscheidung für ein bestimmtes Betriebssystem
die erste zu treffende war.

\subsubsection{Übersicht über PDA-Betriebssysteme}
Im folgenden sollen die einzelnen Systeme samt ihrer für das Projekt
relevanten Eigenschaften vorgestellt werden, um sich für eins zu
entscheiden, daß die software-seitigen Voraussetzungen für einen
Einsatz im Läufer mitbringt.

\begin{description}
\item[PalmOS:] Das System ,,PalmOS'' wurde von der Firma 3Com
  entwickelt und zu\-nächst ausschließlich auf deren PDAs, den
  sogenannten ,,PalmPilots'' eingesetzt.  Mittlerweile hat es PalmOS
  zur Marktführerschaft gebracht und ist auch auf den Geräten von
  Herstellern wie Sony, Handspring und anderen zu finden.
  
  Folglich ist es verständlich, dass als erstes Geräte mit dem System
  des Marktführers ins Auge gefaßt wurden.  Bei den Geräten kann man
  aufgrund der großen Verbreitung mit einer guten Akzeptanz seitens
  der Nutzers des Läufers rechnen.  Auch wird ein eventueller Kunde
  mit hoher Wahrscheinlichkeit schon über ein solches Gerät verfügen.
  
  Ein ,,Palm IIIx'' wurde dann auch Basis eines ersten Versuchs der
  Mechatronik, der im Rahmen einer Studienarbeit von Jörn
  Schlingen\-siepen\cite{Schlinge} stattfand.  Im Rahmen der Arbeit
  wurde die grund\-sätzliche Möglichkeit der Anbindung eines solchen
  Gerätes an den CANBus untersucht und auch bestätigt.
  
  Allerdings verfügt PalmOS in seiner jetzigen Version nicht über
  Multitasking, was einen Einsatz im Läufer nicht ermöglicht.  Die
  geforderte Erweiterbarkeit wird nicht in dem Maße sicherstellt, wie
  es im Läufer erforderlich ist.
  
  Im Bereich der Graphischen Gestaltung des Fahrerinterface erwiesen
  sich die verfügbaren Geräte mit PalmOS als recht eingeschränkt, da
  sie weder über eine anpaßbare Bibliothek von Oberflächenelementen
  noch über genügend Rechenleistung verfügen, um die GUI selbst zu
  ,,malen''.  Bei einem System wie PalmOS ist das jedoch kein
  Design-Fehler, sondern schlägt sich z.B. in der überwiegend
  konstanten und guten Bedienbarkeit der Software für die PalmOS-PDAs
  nieder.  Die an sich gute Eigenschaft wirkt aber vor dem Hintergrund
  unserer Aufgabe negativ aus.
  
  Die Programmierung eines PalmOS-PDAs erfolgt mit speziellen Tools.
  Allerdings haben sich Geräte mit PalmOS im Laufe der Zeit so weit
  verbreitet, daß mehrere alternative Programmierumgebungen und
  Compiler zur Verfügung stehen.  Auch hat die hohe Verbreitung zu
  einer guten und frei verfügbaren Dokumentation der
  Programmierschnittstelle und -Praktiken für das Betriebssystem
  PalmOS geführt.
  
\item[WindowsCE / Pocket PC:] PDAs mit dem System aus dem Hause
  Microsoft zeichnen sich durch Ihre leistungsfähige Hardware aus.  So
  ist es bei WindowsCE-Geräten nicht selten, einen Prozessor mit
  deutlich mehr als 200MHz Taktfrequenz vorzufinden.
  
  Auch verfügt Windows CE über Multitasking, eine permanent im
  Hintergrund laufende Fahrsoftware ist also mit dem System
  realisierbar.
  
  Die graphische Oberfläche ist sehr an die Desktop-Versionen von
  Windows angelehnt.  Die Flexibilität bei der Gestaltung einer
  Oberfläche für die Läufersoftware ist auch unter Berücksichtigung
  der Einschränkung durch die Festlegung auf eine Entwicklungsumgebung
  schon alleine deshalb groß, weil die Geräte über so große
  Leistungsreserven verfügen.  Im Prinzip wird sogar eine komplett
  ,,gemalte'' Oberfläche ermöglicht, auch wenn die dann recht viel
  Speicher verbraucht.
  
  Die Programmierung des Systems erfolgt mittels der bekannten
  Microsoft-Tools wie z.B. Visual C++, welche schon alleine aufgrund
  ihrer Verbreitung bestens dokumentiert sind.  Allerdings ist
  WindowsCE genauso wie PalmOS ein reines PDA-System, so daß die
  Entwicklung für diese PDAs mit den speziellen Tools erfolgen muß und
  zum Testen der Software ein Emulator zum Einsatz kommt.
  
\item[Linux:] Linux ist im gesamten PDA und Embedded-Bereich ein
  Neuling, allerdings mit steigender Verbreitung.  Die steigende
  Verbreitung ist vor allem auf die große Flexibilität des Systems
  zurückzuführen.
  
  Linux verfügt natürlich auch auf dem PDA über echtes Multitasking.
  Schließlich kommt der selbe Kernel und die selbe Systemsoftware zum
  Einsatz wie auf den anderen Plattformen, auf denen es eine
  Implementierung des freien Betriebssystems gibt.
  
  Die Gleichheit in der Software bringt Linux auf dem PDA eine große
  Flexibilität, da direkt die gesamte Software, die es für Linux gibt,
  verfügbar ist.  Betroffen hiervon sind insbesondere die Bibliotheken
  für Entwickler.  So existieren z.B. mehrere GUI-Bibliotheken, die
  noch dazu auf verschiedenen Wegen mit der Hardware kommunizieren
  können.
  
  Aus der identischen Software auf PC/Workstation und PDA folgt aber
  auch, daß man Software für den PDA unter Berücksichtigung einiger
  Randbedingungen auf dem PC entwickeln und testen kann.  Dabei kann
  auf einen Emulator der PDA-Hardware verzichtet werden.  Hierdurch
  wird es ermöglicht, daß Entwickler Software auf Ihrem PC entwickeln
  und mit diesem testen, die dann später durch ein Neuübersetzen
  \footnote{Diesen Vorgang nennt man im Allgemeinen
    ,,crosscompiling''} auf den PDA portiert werden kann.
  
  Die große Flexibilität zieht allerdings auch einen entscheidenden
  Nachteil nach sich: Nahezu jeder Entwickler für Linux-basierte
  Embedded Systems arbeitet mit seinem eigenen Set an Tools,
  Bibliotheken und Compilern.  Daraus folgt, daß es keine große
  Entwicklergemeinde gibt, die alle mit den selben Tools arbeiten, was
  zu einer Unübersichtlichkeit der Dokumentation führt.  Die
  Unübersichtlichkeit wird allerdings durch die Gleichheit des
  Systems zu dem auf PCs teilweise wieder ausgeglichen.
\end{description}  


\subsubsection{Entscheidung}
Tabelle \ref{mw_pda_os_tabelle} zeigt nochmals eine Übersicht der
Systeme mit ihren individuellen Eigenschaften.

PalmOS ist wegen der fehlenden Multitasking-Fähigkeit für unsere
Aufgabe ungeeignet.  Somit musste die Entscheidung zwischen Linux und
Windows CE getroffen werden.
  
Wir haben uns letztendlich für Linux entschieden, um uns die größte
Flexibilität zu sichern.  Betroffen hiervon ist nicht nur die oben
schon ausgeführte Auswahl an GUI-Bibliotheken, sondern auch die
Möglichkeit im Falle der Notwendigkeit selbst am Betriebssystem Hand
anlegen zu können.  Da wir ein klassisches Embedded System durch einen
handelsüblichen PDA ersetzten, war zu Beginn nicht klar, welche
Probleme dabei auftreten können.  Und mit einem unabänderlichen
Betriebssystem wären solche Probleme eventuell nicht lösbar.
  
Zusätzlich ist es mit einem Linux-PDA möglich, Software auf PCs zu
entwickeln und zu testen, ohne daß dazu ein PDA oder gar ein Emulator
nötig ist.

\begin{table}
  \caption{Übersicht über die verschiedenen PDA-Betriebssysteme}
  \label{mw_pda_os_tabelle}
  \begin{center}
    \begin{tabular}{|c|c|c|c|}
      \hline
      \emph{Anforderung} & \emph{PalmOS} & \emph{WindowsCE} & \emph{Linux} \\
      \hline
      \emph{Multitasking} &$\circ$ &$\bullet$ & $\bullet$\\
      \hline
      \emph{GUI-Flexibilität} &$\circ$ &+ & ++\\
      \hline
      \emph{Programmierung} &$\circ$ &+&++\\
      \hline
      \emph{Dokumentation und Support} &++ &+ &+\\
      \hline
    \end{tabular}
  \end{center}
\end{table}



\subsection{Auswahl der Hardware\label{mw_pda_uebersicht}}
Im folgenden sollen kurz die PDAs beschrieben werden, die für das
Projekt in Frage kamen, und die in folge dessen auch näher geprüft
wurden.

Da der Markt für Linux-basierte PDAs sehr in Bewegung ist, kann und
soll hier keine vollständige und insbesondere keine aktuelle Übersicht
gegeben werden.  Ein guter Anlaufpunkt für eine solche ist die
Homepage von Linuxdevices\footnote{http://www.linuxdevices.com}.



\begin{description}
\item[Agenda VR3:] Diesem PDA, der in Abbildung \ref{mw_agenda} zu
  sehen ist, gebührt die Ehre des ,,first-to-market''-Gerätes im
  Bereich Linux-PDAs, da es Agenda Computing als erstes gelang, einen
  endkundentauglichen PDA mit Linux als Betriebssystem in die Läden zu
  bringen.
  \begin{figure}
    \center
    \includegraphics[width=7.0cm]{mw/bilder/agenda.eps}
    \caption{Der Agenda VR3}
    \label{mw_agenda}
  \end{figure}
  
  Leider gab es zum Zeitpunkt der Entscheidung noch keine
  Farb-Variante dieses Geräts. Farbe ist aber in einer
  Design-orientierten Entwicklung wie dem Läufer ein absolutes Muß.
  
\item[G.Mate Yopy:] Abbildung \ref{mw_yopy} zeigt den G.Mate Yopy, der
  lange Zeit als Mythos durch die diversen News-Seiten und -Foren des
  Internet geisterte. Ihm wurde am ehesten zugetraut, der erste
  brauchbare PDA mit Linux als Betriebssystem zu sein.  Die Hoffnung
  der Linux-Enthusiasten wurde nicht zuletzt durch die Präsentation
  des Yopy auf der CeBIT 2000 durch den damaligen G.Mate-Partner
  Samsung genährt.

  \begin{figure}
    \center
    \includegraphics[width=7.0cm]{mw/bilder/yopy.eps}
    \caption{Der G.Mate Yopy}
    \label{mw_yopy}
  \end{figure}
  
  Nachdem Samsung jedoch aus dem Projekt ausgestiegen ist, ist es
  ruhig um den Yopy geworden. In Deutschland war kein solches Gerät
  auszumachen.  Somit kam der Yopy leider nicht für das Projekt in
  Frage, zumal seine Zukunft nach wie vor ungeklärt ist und somit eine
  Versorgung der Nullserie des Läufers mit Geräten nicht sicher war.
  
  Auf der CeBIT 2002 wurde der Yopy wieder gezeigt, jedoch nun mit
  einem völlig neuen mechanischen Aufbau, der an ein klappbares
  Mobiltelefon erinnert.  Eine solche Form paßt nicht zu den Anforderungen
  an einen PDA im Läufer, weshalb sich die Entscheidung gegen diesen
  PDA auch im Nachhinein als richtig erwiesen hat.

  
\item[VTech Helio:] Siehe Abbildung \ref{mw_helio}.  Hierbei handelt es
  sich um einen PDA der Firma VTech, der mit dem proprietären VT-OS
  als Betriebssystem betrieben wird.  VTech unterstützt allerdings
  auch die Entwicklung einer Linux-Distribution für den Helio.
  \begin{figure}
    \center
    \includegraphics[width=7.0cm]{mw/bilder/helio.eps}
    \caption{Der VTech Helio}
    \label{mw_helio}
  \end{figure}
  
  Der PDA macht von seiner äußeren Erscheinung mehr den Eindruck eines
  Spielgerätes für Kinder, was ja auch der Haupt-Markt des Anbieters
  VTech ist.  Der PDA verfügt ausserdem nicht über ein Farb-Display,
  so daß er für das Projekt ebenfalls nicht in Frage kam.
  
  
\item[Casio Cassiopeia:] Die PDAs dieser Serie sind überaus
  leistungsfähig.  Sie verfügen über einen Prozessor auf Basis der
  MIPS-Architektur bei 125MHz-150MHz, bis zu 32MB RAM und Farbdisplays
  mit einer Auflösung von 320x240 Pixel.  Auf der Seite der Hardware
  spricht also vieles für den Cassiopeia. Abbildung \ref{mw_casio}
  zeigt den Cassiopeia.
  
  \begin{figure}
    \center
    \includegraphics[width=7.0cm]{mw/bilder/casio.eps}
    \caption{Der Casio Cassiopeia}
    \label{mw_casio}
  \end{figure}
  
  Ebenfalls verfügbar ist eine Implementierung des Linux Kernels für
  diese Geräte.  Allerdings besitzen die Geräte dieser Serie kein
  wiederbeschreibbares Flash-ROM, sondern nur ein ROM für das
  Betriebssystem, so daß ein Start von Linux immer über spezielles
  WindowsCE Programm namens ,,CyaCE'' erfolgen muß.  Im Rahmen einer
  \emph{Produkt}entwicklung ist es jedoch nicht wünschenswert, dass
  sich ein potentieller Nutzer zu sehr mit den technischem
  Details des Fahrzeuges auseinandersetzen muß.
  
  Ein weiteres, nicht zu unterschätzendes Argument gegen die Geräte
  dieser Serie ist, daß sie von einem Asiatischen Hersteller
  vertrieben werden, und diese sich bisher als eher unwillige
  Sponsoren des Projektes erwiesen haben.
  
  
  
\item[Compaq IPAQ:] Der Compaq IPAQ (siehe auch Abbildung
  \ref{mw_ipaq_bild}) ist von der Hardware her dem Sharp-PDA sehr
  ähnlich, der einzige Unterschied liegt in der standardmäßig
  ausgelieferten Software.  Der IPAQ kommt standardmäßig mit Windows
  CE, während der Sharp mit Linux ausgestattet wird.
  \begin{figure}
    \center
    \includegraphics[width=7.0cm]{mw/bilder/Menu.eps}
    \caption{Der Compaq IPAQ mit der Läufer-Software für die Cebit 2002}
    \label{mw_ipaq_bild}
  \end{figure}
  
  Für den IPAQ existiert allerdings eine sehr weit fortgeschrittene
  Portierung des Linux Kernels und etlicher Programme, so daß
  mittlerweile sogar schon mehrere Distributionen um die Gunst des
  IPAQ-Besitzers buhlen.  Siehe dazu auch Kapitel \ref{mw_ipaq_linux}
  
  Die Hardware des IPAQ H3660 stellt wohl derzeit das technisch
  machbare im PDA-Umfeld dar. Das Gerät bietet Leistungen, die ein
  Entwickeln auf normalen Desktop-Rechnern ermöglicht, ohne das
  Unbehagen, die Zielplattform könnte eine bestimmte Funktionalität
  aus Gründen der dort vorhandenen Ressourcen nicht zur Verfügung
  stellen.
  
  Die Hardware des IPAQ im Einzelnen:
  
  \begin{description}
  \item[CPU:] StrongARM 206MHz
  \item[RAM:] 64MB
  \item[Flash:] 16MB interner Flash-Speicher
  \item[Display:] 240x320 12Bit reflektives Farbdisplay
  \item[Schnittstellen:] RS-232, USB, IRDA, Analog Sound
  \item[Erweiterungen:] Es besteht die Möglichkeit, den IPAQ um
    folgende Slots zu erweitern: CompactFlash, 1x PCMCIA oder 2x
    PCMCIA.  Hierzu wird der IPAQ in seine eigene Erweiterung, ein so
    genanntes ,,Jacket'' hineingesteckt, was Veränderungen im
    Formfaktor zur Folge hat. Die Jackets gibt es in Ausführungen mit
    den genannten Steckplatz-Konfiguration.
  \end{description}
  
\item[Sharp Zaurus:] Dieser PDA verfügt über ähnliche technische Daten
  wie der Compaq IPAQ.  Wie dieser verfügt er über einen StrongARM
  206MHz Prozessor, 64MB RAM und 16MB Flash.  Auch das Display ist
  ähnlich dem des Compaq. Abbildung \ref{mw_sharp} zeigt dieses Gerät.

  \begin{figure}
    \center
    \includegraphics[width=7.0cm]{mw/bilder/sharp.eps}
    \caption{Der Sharp Zaurus}
    \label{mw_sharp}
  \end{figure}
  
  Allerdings wird der zu Beginn der vorliegenden Arbeit noch nicht mit einem
  Namen versehene PDA nicht mit Windows CE, sondern mit Linux als
  Betriebssystem ausgeliefert. Die Software entspricht weitgehend der,
  die wir auf dem IPAQ einsetzen. Es kommt also ein Linux Kernel 2.4.X
  mit QTopia als graphischer Oberfläche zum Einsatz.
  
  Leider war das Gerät zu Beginn unserer Arbeit noch nicht verfügbar,
  so daß wir das von all seinen Daten her ideale Gerät leider nicht
  verwenden konnten.  Auf der Cebit 2002 wurden erste Kontakte mit
  Sharp geknüpft, um ein eventuelles Wechseln auf den Sarp Zaurus
  vorzubereiten.

\end{description}

\subsubsection{Entscheidung}
Tabelle \ref{mw_pda_tabelle} zeigt nochmals eine Übersicht über die
verschiedenen PDAs mit ihren individuellen Eigenschaften.  Die Wahl
fiel letztlich auf einen Compaq IPAQ, da das Gerät nach den
Informationen, die zur Zeit der Entscheidung im WWW zur Verfügung
standen, über die weitestgehende Unterstützung unter Linux verfügt.
Ein weiteres wesentliches Argument für dieses Gerät ist das reflektive
Display. Dadurch wird eine Nutzung als zentrale Anzeige in einem
Fahrzeug überhaupt erst möglich.  Durch das reflektive Display wird
die Anzeige des IPAQ bei stärkerer Sonneneinstrahlung automatisch
heller, so daß im Gegensatz zu z.B. Notebooks ein Ablesen auch im
Sommer bei großer Helligkeit möglich ist.

Leider war es zu Beginn der vorliegenden Arbeit nicht möglich, den
Sharp Zaurus zu berücksichtigen, da er zu diesem Zeitpunkt nicht zur
Verfügung stand.  Im weiteren Projektverlauf wird allerdings versucht,
auf den Zaurus umzusteigen, da er über ähnliche Leistungen wie der
IPAQ verfügt, jedoch direkt mit Linux ausgeliefert wird.  Die
Verwendung eines Standard-PDA macht vor dem Hintergrund einer

\emph{Produkt}entwicklung natürlich Sinn.
\begin{table}
  \caption{Übersicht über die verschiedenen Linux-fähigen PDAs}
  \label{mw_pda_tabelle}
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|}
      \hline
      \emph{Anforderung} & \emph{Display} & \emph{Optik} & \emph{Anschlußmöglichkeiten} & \emph {Verfügbarkeit}\\
      \hline
      \emph{VR3}         & -- & 0 & 0 & + \\
      \hline
      \emph{Yopy}        &  + & + & 0 & -- \\
      \hline
      \emph{Helio}       & -- & --& 0 & + \\
      \hline
      \emph{Cassiopeia}  &  + & + & + & -- \\
      \hline
      \emph{Zaurus}      & ++ & + & + & (-) \\
      \hline
      \emph{IPAQ}        & ++ & ++& + & + \\
      \hline
    \end{tabular}
  \end{center}
\end{table}


\subsection{Zusammenfassung}
Wie weiter oben beschrieben wurde die Entscheidung zugunsten von Linux
gefällt; Linux auf dem PDA ist sehr PC-ähnlich zu programmieren und
verfügt über Multitasking.  Außerdem ist es im Bereich der GUI sehr
flexibel und es ist nicht unbedingt ein PDA nötig, um Komponenten für
die Läufer-Software zu entwickeln.

Für den IPAQ wurde sich entschieden, weil er die beste Wahl nach dem
noch nicht verfügbaren Sharp Zaurus darstellt.  Das Gerät verfügte als
erstes am Markt über ein \emph{reflektives}
TFT-Display\footnote{TFT=Thin Film Transistor}, was den Einsatz in
einem offenen Fahrzeug überhaupt erst möglich macht.  


\newpage
\section{Auswahl der Linux-Distribution}
\subsection{Anforderungen}
Für den IPAQ standen zum Zeitpunkt der Entscheidung mehrere
Linux-Distributionen zur Auswahl.  Es mußte sich also innerhalb des
Projektes für eine entschieden werden.  Dabei waren die Anforderungen
der Entwickler mechatronischer Komponenten ebenso zu berücksichtigen
wie die späteren Nutzer des Läufers.

Für Entwickler ist es am wichtigsten, daß ihnen die Entwicklung für
das System möglichst leicht gemacht wird.  Dies schließt eine
ordentliche Programmierschnittstelle ebenso ein wie gute Werkzeuge zum
Erstellen der Graphischen Benutzerschnittstelle.  Aber auch ein gutes
Management der Softwareinstallation auf dem Gerät ist dem Entwickler
wichtig.

Für den Anwender ist der Mehrfachnutzen des Gerätes entscheidend.  Es
soll zusätzlich noch als ,,normaler'' PDA nutzbar bleiben.  Dazu
gehört eine ausgereifte Auswahl an Anwendungen zur Termin- und
Adreßverwaltung.  Aber natürlich auch ein umfangreiches
Softwareangebot, was auch die Möglichkeit bietet, neue Versionen der
installierten Software einfach einspielen zu können.  Dies gilt
insbesondere für die Systemsoftware, also die Distribution an sich,
aber auch für die für den Läufer speziell angefertigte Software.



\subsection{Die Alternativen}\label{mw_ipaq_linux}
Compaq selbst unterstützt maßgeblich die Portierung des Linux-Kernels,
ist aber mittlerweile aus der Entwicklung einer eigenen darauf
aufsetzenden Distribution ausgestiegen, da mehrere aus der Sicht
Compaqs besser Alternativen zur Verfügung stehen.  Zur Entstehungszeit
der vorliegenden Ausarbeitung befindet sich Linux auf PDAs und
insbesondere auf dem IPAQ unter dem Einfluß starker
Entwicklertätigkeit, so daß viele Distributionen und Programme sich
noch im Zustand ,,Projekt'' befinden und erst nach und nach zu
,,Produkten'' werden.  Das prominenteste ,,Produkt'' dürfte der Sharp
Zaurus sein, dessen Software weitgehend mit der freien Oberfläche OPIE
übereinstimmt.

Im folgenden sollen die einzelnen Projekte, die sich um Linux auf dem
IPAQ bemühen, vorgestellt werden.  Wie auch schon bei der Übersicht
über aktuelle Linux-PDAs (siehe \ref{mw_pda_uebersicht}) kann und soll
hier kein vollständiger Überblick über die Projekte gegeben werden.
Die Projekte, die hier genannt werden, sind die, die im Rahmen dieser
Studienarbeit näher untersucht wurden.\\
Die einzelnen Projekte sind:

\begin{description}
\item[PocketLinux:] PocketLinux\cite{plinux} kann man wohl mit Fug und
  Recht als das ambitionierteste Projekt bezeichnen.  PocketLinux
  setzt sich aus einem Linux-Kernel, eine Java Virtual
  Machine\footnote{Kurz: Java VM bzw. JVM} sowie einer
  XML\footnote{eXtensible Markup Language}-basierten GUI zusammen.
  Leider hat ein kurzer Test der Version für x86-Linux zu der
  Erkenntnis geführt, daß die Kombination Java+XML+PDA wohl (noch)
  nicht performat genug ist, um die Ansprüche des Projekts Läufer an
  das Ansprechverhalten der Software zu erfüllen.
  
  Mittlerweile wurde die Entwicklung von PocketLinux auch eingestellt.
  Die Entwicklung der Java VM geht allerdings weiter und wird als
  eigenständige JVM für Embedded Devices entwickelt.
  
\item[Familiar Linux:] Familiar\cite{flinux} ist die
  ,,Brot-Und-Butter'' Distribution von Linux auf dem IPAQ.  In ihr
  sind auch die früheren Compaq-Distri\-butionen aufgegangen.
  
  Familiar verfügt über ein Debian-ähnliches Paketsystem, wodurch die
  Installation weiterer Software sehr einfach möglich ist.  Jede
  verfügbare Software ist hierzu in Pakete organisiert, die womöglich
  untereinander durch Beziehungen verbunden sind.  Die Pakete werden
  dazu automatisch aus dem Internet geladen und eventuelle
  Abhängigkeiten zu anderen Softwarepaketen werden aufgelöst.  Dadurch
  werden dem Anwender die von anderen Linux-Systemen bekannten
  Probleme mit Abhängigkeiten zwischen Softwarepaketen erspart.  So
  führt z.B.  die Installation eines graphischen Programms automatisch
  zur Installation der benötigten Umgebung.  Für das Paketsystem der
  Distribution Familiar existieren verschiedene graphische Frontends,
  so daß die Handhabung der Softwareverwaltung für den Anwender sehr
  einfach möglich ist.
  
  In der Standardinstallation verwendet Familiar das von
  UNIX-Workstations bekannte XWindow System in der Version 11 (kurz
  X11) als graphische Schnittstelle, es existieren aber auch andere
  graphische Oberflächen.  Die Portierung bestehender Anwendungen ist
  recht einfach, da X11 als Fenstersystem auf nahezu jeder auf UNIX
  oder seinen Artverwandten basierenden Workstation Verwendung findet.
  Allerdings sind diese Anwendungen in der Regel nicht auf den kleinen
  Bildschirm des PDA hin optimiert, da an UNIX Workstations historisch
  gesehen schon immer sehr große Monitore mit großer Auflösung üblich
  waren.  Ebenfalls verfügbar sind die ersten X11-basierte
  Anwendungen, die speziell für Familiar entwickelt wurden.  Die
  Anwendungen decken den Bereich der Organizer-Software ab und
  berücksichtigen natürlich die spezielle Hardware, auf der sie laufen
  sollen.
  
\item[Intimate:] Das Ziel des Projektes ,,Intimate'' ist es, ein
  komplettes Debian-Linux auf den IPAQ zu bringen.  Hierfür wird mehr
  Speicherplatz benötigt, als der IPAQ in seiner Standard-Version zur
  Verfügung stellt.  Deshalb setzt die Installation von Intimate
  zwingend das Vorhandensein einer externen Speichermöglichkeit
  voraus.  Meistens wird wohl ein IBM Microdrive zum Einsatz kommen,
  das 1GB an Speicher im Formfaktor einer CompactFlash-Karte bietet.
  
  Intimate entschädigt für den geschilderten Aufwand mit einer
  Softwareauswahl, die (fast) auf dem Niveau von Linux auf
  Intel-Rechnern liegt.  Insbesondere sind die bekannten Pakte wie
  Gnome, KDE, Mozilla, Emacs und andere verfügbar.  Die Anwendungen
  leiden jedoch unter dem kleinen Display des PDA, das über eine
  Auflösung von 240x320 Pixel verfügt.
  
  Für den Läufer ist allerdings eine weitgehende Verfügbarkeit von
  Desktop- und Server-Anwendungen nicht unbedingt erforderlich, ja
  sogar hinderlich, da es im Bereich der XWindow-Anwendungen derzeit
  noch keine wirklich zufriedenstellende Software für den PDA-Einsatz
  gibt.  Die benötigte Festplatte braucht überdies recht viel Strom,
  wodurch sich Intimate für die gegebene Anwendung als ungeeignet
  erwies.

  
\item[QTOPIA:] QTOPIA ist keine eigene Distribution, sondern ein Set
  von PDA-Anwendungen die auf der QT-Bibliothek des Norwegischen
  Herstellers Trolltech basieren.
  
  Die Bibliothek wurde in der Version QT/Embedded (QTE) speziell an
  die Bedürfnisse von PDAs angepaßt.  QTE operiert direkt auf dem
  Linux Framebuffer und nicht auf dem X Window System.  Dadurch spart
  es Speicherplatz und Rechenzeit, verliert aber den Vorteil von X11,
  nämlich die Netzwerkfunktionalität.
  
  QTE ist je nach Art der Kompilierung voll Sourcecode-kompatibel zu
  den anderen QT-Varianten für Windows, XWindow, MacOS, etc.  Um aus
  einer bestehenden QT-Anwendung für z.B. das XWindow System eine
  Anwendung für den PDA zu machen, Bedarf es keiner Änderungen,
  vorausgesetzt die GUI paßt auf den Bildschirm des PDA.  Daraus folgt
  eine ungemeine Vereinfachung der Programmierung.


  QT genießt außerdem den Ruf einer sehr guten Dokumentation, was
  den Entwicklern mechatronischer Komponenten sicher zugute kommen
  sollte.
  
  QTOPIA stellt nun eine komplette PDA-Umgebung auf Basis der
  Klassenbibliothek QT zur Verfügung.  QTOPIA schliesst von
  Rahmenbedingungen, wie verschiedenen Formen der Texteingabe
  (Handschrift, Virtuelle Tastatur, T9\footnote{Bei T9 werden wie beim
    Handy die Worte nach einigen wenigen Zeichen erkannt} etc.) ein.
  Zusätzlich umfaßt das PDA System ebenfalls einen ordentlichen
  Grundstock an Anwendungen, die man auf einem PDA erwartet.  Dazu
  gehören neben der PIM\footnote{Personal Information Manager}-Suite
  auch ein Betrachter für Dateien von Tabellenkalkulationen, ein
  Webbrowser sowie Email-Client und nicht zuletzt eine Anzahl an
  Spielen.
  
  QTOPIA findet z.B. auf dem Sharp Zaurus Verwendung, was für die
  Produktreife der Software spricht.
\end{description}

\subsection{Die Entscheidung}
Für die Verwendung im Läufer wurde QTOPIA auf Familiar gewählt, da
dies unter den gegebenen Umständen die fortgeschrittenste Wahl
darstellte.  Familiar mit X11 kam trotz der technischen Überlegenheit
des XWindow Systems nicht zum Zuge, da es an guten PDA Anwendungen für
die Workstation-Grafikschnittstelle fehlte.  QTOPIA ist explizit für
den Einsatz auf PDAs entwickelt und stellt darüber hinaus sogar eine
sehr gute Programmierschnittstelle zur Verfügung.

Auch die Aussicht auf kommerziell verfügbare PDAs mit QTOPIA
beeinflußte die Entscheidung maßgeblich, genauso wie die Qualität
anderer auf QT aufsetzender Softwarepakete wie z.B. KDE.



\newpage
\section{Klassenbibliothek}
Abbildung \ref{mw_schnittstellen} zeigt die von der Klassenbibliothek
zu unterstützenden Schnittstellen (schraffiert).  Diese Schnittstellen
sollen dem Entwickler mechatronischer Komponenten durch die
Klassenbibliothek auf dem PDA zugänglich gemacht werden.

Die den Entwicklern mechatronischer Komponenten zur Verfügung
gestellte Programmierschnittstelle bestimmt maßgeblich deren
Produktivität und die Qualität der von ihnen erstellten Software.  In
folge dessen kommt der Klassenbibliothek eine besondere Bedeutung zu,
die in etwa der des richtigen PDAs aus der Sicht der späteren Nutzer
des Läufers entspricht.


Auf die beiden Bereiche Treiber - CAN-Bus sowie Treiber - GUI soll im
folgenden eingegangen werden.  Dem voran stehen einige Anforderungen,
die sich aus den schon weiter oben in Kapitel \ref{aufgabe_kapitel}
beschriebenen Anforderungen an das Gesamtsystem herleiten.

\begin{figure}
  \center
  \includegraphics[width=7.0cm]{mw/bilder/schnittstellen.eps}
  \caption{Die abzudeckenden Schnittstellen (schraffiert)}
  \label{mw_schnittstellen}
\end{figure}


\subsection{Anforderungen}
Die Programmierschnittstelle hat zwei wichtige Aufgaben: Die
Bereitstellung einer einfach zu verwendenden Kommunikation zwischen
PDA und Platinen sowie eine Schnittstellendefinition zwischen PDA
Software und dem Interface, mit dem der Fahrer auf die Fahrzeugsysteme
zugreifen kann.

Dabei müssen die für das Projekt spezifischen Randbedingungen
Beachtung finden: Zu den Randbedingungen zählt, daß mehrere Entwickler
parallel und wahrscheinlich ohne Kenntnis voneinander an Komponenten
für den Läufer arbeiten werden. Außerdem war zu Beginn der
vorliegenden Arbeit noch nicht vollständig sicher, über welche
mechatronischen Systeme der Läufer mal verfügen wird.  Trotz des
unsicheren Umfeldes müssen die gesamten Software- und
Hardware-Komponenten am Ende der Entwicklung an einer Stelle zentral
zusammengeführt und kontrolliert werden können.

Es ist also notwendig, die Entwickler so gut es möglich ist voneinander
unabhängig zu machen, es aber trotzdem zu ermöglichen, deren Arbeit am
Ende in einem Gesamtsystem zusammen zu führen.


\subsection{Die Kommunikation im Läufer aus PDA Sicht}\label{mw_com}
Um die Entwickler mechatronischer Komponenten für den Läufer
voneinander zu trennen, ist eine Kommunikationsstruktur notwendig, die
dem durch die Bereitstellung virtueller privater Verbindungen zwischen
PDA Software und Platine Rechnung trägt.  Somit wurde ein
Designmerkmal des CANBus' dieser Anforderung geopfert.  Für die
näheren Details der Kommunikationsprotokolle im Läufer sei auf Kapitel
\ref{jameson_kapitel} verwiesen.  Hier soll nun im folgenden auf die
Anwender- bzw. Entwicklersicht auf die Kommunikation vom PDA aus
eingegangen werden.

Die Grundidee der Kommuníkation im Läufer ist die der
objektorientierten Programmierung (OOP).  Wir verstehen das physische
Gerät und auch seinen Treiber als \emph{Objekte}, die sich gegenseitig
\emph{Nachrichten} schicken.  Die Objekte selber haben einen Status,
sind also Statusmaschinen.  Ein physisches Gerät und sein Treiber
stellen nun gekoppelte oder kommunizierende Statusmaschinen dar.  Wenn
sich der Status des einen \emph{signifikant} ändert, teilt es diesen
Statusübergang dem jeweils anderen mit.  \emph{Signifikant} meint in
diesem Zusammenhang, dass nur solche Statusübergänge dem anderen
mitgeteilt werden, die für diesen auch von Bedeutung sind.  

Als Beispiel für die Klassifikation von Übergängen siehe Bild
\ref{mw_blinker_zustaende}.  Dort wird ein einfaches Übergangsdiagramm
für einen Blinker dargestellt.  Die fett gezeichneten Übergänge werden
dabei extern, also durch eine Nachricht des Treibers ausgelöst.  Wenn
nun das Gerät eine Fehlfunktion feststellt, geht es in den Zustand
$Z2$ über.  Dieser Übergang ist signifikant, da der Treiber im PDA
davon unterrichtet werden muss.  Nicht signifikant sind die übergänge 


\begin{figure}
  \center
  \includegraphics[width=14cm]{mw/bilder/zustaende.eps}
  \caption{Übergangsdiagramm eines modellhaften Blinkers. Fette Linien
  bedeuten Übergänge, die vom Treiber aus ausgelöst wurden.}
  \label{mw_blinker_zustaende}
\end{figure}



Grundbausteine der Kommunikation im Läufer sind so genannte
Nachrichten\footnote{im folgenden auch: Message}, die von einem
Bus\-teil\-nehmer zum anderen gesendet werden.  Jeder Busteilnehmer
erhält dazu eine im System eindeutige Nummer, die sogenannte
ID\footnote{ID: für IDentifier}.  Über die Komponenten-ID wird die
Verbindung zwischen einem realen Gerät, also z.B. einem
Scheibenwischer und dem entsprechenden Treiber auf dem PDA
hergestellt.  Die Kommunikationsstruktur des Läufers macht das Routing
der Nachrichten über den CANBus für den Entwickler transparent, d.h.
er muß sich lediglich darum kümmern, daß sich sein Gerät und der
dazugehörige Treiber unter der selben ID beim System anmelden.

Die eigentliche Kommunikation erfolgt dann wie schon gesagt in Form
von Nachrichten, die zwischen dem Treiber und dem zu ihm gehörenden
Gerät ausgetauscht werden.  Bei den Nachrichten handelt es sich immer
um einen Befehl (8Bit) mit optionalen Parametern (15Bytes).  Dadurch
kann sich jeder Entwickler für sein Gerät einen eigenen Satz an
Befehlen definieren, ohne daß der Befehlsatz jedes Gerätes den anderen
Teilnehmern im System bekannt sein muß.  Details zur Kommunikation
finden sich in Kapitel \ref{jameson_kapitel}.



\subsection{Implementierung}\label{mw_klasse}
Ziel der Entwicklung der Klassenbibliothek ist es, die Entwicklung
darauf aufsetzender Komponenten so einfach wie möglich zu machen, da
die Entwickler, die die Komponenten entwickeln werden, sich neben der
Programmierung auch noch anderen Teilen ihrer Komponente widmen
müssen.  Die auf der entwickelten Bibliothek aufsetzenden Module sind
genauer:

\begin{description}
\item[Treiber] Die Treiber stellen ein Interface zu den einzelnen
  mechatronischen Komponenten her.  Dazu sollen sie das Gerät durch
  eine Klasse repräsentieren, die als Methoden die speziellen
  Fähigkeiten des Gerätes exportiert.  Hierzu ist es nötig, den
  Entwicklern durch die Klassenbibliothek ein Interface zum CANBus
  zur Verfügung zu stellen.  Außerdem müssen die Treiber auf
  Nachrichten sowohl von der GUI als auch von ihrem Gerät am CANBus
  reagieren können.
  
\item[GUI] Die GUI soll später das Interface zum Fahrer darstellen.
  In ihr werden alle Fäden zusammengeführt werden, die als Methoden
  aus den einzelnen Klassen laufen.  Dazu muß es für den Entwickler
  der GUI einfach sein, auf die Methoden der Treiber zuzugreifen und
  deren Statusmeldungen zu erhalten.

\end{description}

Die genannten Module sind nicht Teil der vorliegenden Studienarbeit,
da ihre Implementierung im Falle der Treiber am besten durch den
Entwickler der mechatronischen Komponenten durchgeführt wird.  Nur der
Entwickler hat das Detailwissen, um die Treiber dem mechatronischen
Gerät angemessen zu entwickeln.  Im Falle der GUI kann diese erst dann
erstellt werden, wenn alle Fahrzeugkomponenten feststehen, da in ihr
auch die Fahrzeuglogik festgehalten wird. Um die Fahrzeuglogik zu
implementieren, bedarf es genauerer Kenntnisse der Fahrdynamik des
Läufers als die Autoren haben können, schon aufgrund ihrer
Fachrichtung.

Aufgabe ist es also, zwei Schnittstellen zu definieren. Im einzelnen
sind es die Anbindung der GUI an die Treiber sowie die Kommunikation
zwischen Treiber und CANBus.

\subsection{Anbindung der GUI an die Treiber}
Die GUI muß Befehle an die Treiber geben können.  Das läßt sich recht
einfach dadurch erreichen, daß die Treiber als lokale Variablen in der
GUI Vorliegen.  Die GUI wird also zum Hauptbestandteil des
Software-Systems des Läufers.

Die umgekehrte Kommunikation gestaltet sich etwas schwieriger.  Bei
der Anbindung der GUI an die Treiber kann man grundsätzlich
Verschiedene Wege gehen:
\begin{description}
\item[Callback] Zum einen kann man allen Treibern bei der
  Initialisierung einen Pointer auf die GUI übergeben.  Dabei muß aber
  jeder Treiber die GUI und ihre Methoden schon kennen.  Da diese aber
  nicht Teil der vorliegenden Arbeit sein kann, ist die verbreitete
  Methode des Callback für unsere Anwendung leider nicht sehr
  geeignet.
  
  Eine Alternative hierzu wäre es, dem Treiber ein vermittelndes
  Objekt zu übergeben, das eine Methode enthält, die einen String
  entgegennimmt.  Hierduch kann man die gewünschte Flexibilität
  erreichen, da ein späterer Autor der GUI mittels Stringvergleichen
  erkennen kann, was für ein Ereignis aufgetreten ist.
  Stringvergleiche sind allerdings nicht sehr effizient und auch im
  Läufer gar nicht nötig, wie im folgenden Text deutlich wird.
  
\item[Polling] Die GUI könnte auch die Treiber in regelmäßigen
  Abständen Pollen, d.h. eine bestimmte im Framework zu definierende
  Methode der Treiber-Objekte aufrufen.  Über einen solchen
  Mechanismus würde dann jeder Treiber Rechenzeit erhalten und könnte
  eingehende Nachrichten bearbeiten.
  
  Die Methode des Polling bietet die gewünschte Flexibilität, da die
  GUI nur noch die Treiber kennen muß, aber nicht umgekehrt.
  Allerdings ist es offensichtlich, daß ein solches Vorgehen starke
  Probleme hinsichtlich der Leistung hat.  Zum einen wird so keine
  bedarfsgerechte Verteilung der CPU Leistung erreicht und zum anderen
  kostet das unnötige Aufrufen von Methoden, die derzeit nichts zu tun
  haben, unnötig Rechenzeit.
  
\item[Signals und Slots] Für die GUI kommt das Produkt ,,QTOPIA'' der
  Firma Trolltech zum Einsatz, folglich stand eine weitere Möglichkeit
  zur Verfügung, die Kommunikation zwischen Treiber und GUI zu
  realisieren.  Die auf QTOPIA basierende Lösung ist im Gegensatz zu
  den anderen Ansätzen nicht zu den Standard-Techniken zu zählen,
  weshalb hier eine Erläuterung des bei Trolltech entwickelten
  Verfahrens gegeben werden soll.
  
  QT verfügt über einen Mechanismus, der mit sogenannten ,,Signals''
  und ,,Slots'' arbeitet.  Signale und Slots können eine beliebige
  Anzahl Argumente beliebigen Typs übermitteln und sind überdies
  typsicher.
    
  Ein Objekt verschickt Signale, durch welche Slots von verknüpften
  (connected) Objekten aufgerufen werden. Am besten läßt sich dies an
  einem kleinen Beispiel zeigen:
  
\begin{verbatim}
class Foo : public QObject
 {
  Q\_OBJECT
  public:
    Foo();
    int  value() const { return val; }
  public slots:
    void setValue( int );
  signals:
    void valueChanged( int );
  private:
    int  val;
 };
\end{verbatim}
    
  Die Ausdrücke ,,Q\_OBJECT'', ,,slots'' und ,,signals'' werden vom
  Meta Object Compiler (moc) benötigt.  Dieser Compiler erzeugt ein
  neues C++-Sourcefile, das Code enthält, der das Objekt
  initialisiert.  Dieses File muß compiliert und zu den anderen
  Objekt-Files gelinkt werden.  Die genannten Ausdrücke werden vom
  Präprozessor entfernt bzw. so verändert, daß der C++-Compiler den
  Code problemlos übersetzen kann.
    
  Die Implementation von Foo::setValue():
\begin{verbatim}
void Foo::setValue( int v ) 
 {
   if ( v != val ) {
    val = v;
    emit valueChanged(v);
   }
 }
\end{verbatim}
  
  Ein weiterer moc-Ausdruck ist ,,emit'', womit ein Signal versendet
  wird.  Nun werden zwei Instanzen von Foo miteinander verbunden:

\begin{verbatim}
Foo a, b;
connect(&a, SIGNAL(valueChanged(int)), &b, SLOT(setValue(int)));
b.setValue( 110 );
a.setValue( 88 );
b.value();          // gibt 88 zurück
\end{verbatim}
    
  Durch Aufrufen von a.setValue() verschickt a ein Signal, worauf der
  damit verbundene Slot b.setValue() aufgerufen wird.
  
  Durch den Signal/Slot-Mechanismus von QT können zwei Objekte
  zusammen\-arbeiten, ohne daß sie sich gegenseitig kennen (es muß nur
  jemand da sein, der sie verknüpft).  Ein solcher Mechanismus
  erleichtert die Programmierung von GUIs ungemein, da in einem neuen
  Widget\footnote{Element einer graphischen Oberfläche} oft
  Standardkomponenten wie Pushbuttons etc. eingebunden werden müssen.
  QT übernimmt für den Programmierer die Verwaltung solcher
  Standardkomponenten, sie müssen nur dynamisch alloziert (mit new)
  und connected werden.
  
  Genau das ist aber auch bei der Kommunikation im Läufer mehr als
  nützlich: Die Treiber können unabhängig von der GUI entwickelt
  werden und auch in eventuellen Nachfolgeprojekten Verwendung finden.
  Sie stellen ihre Funktionalität als Slot zur Verfügung und
  emittieren Signale, wenn sie der GUI etwas mitteilen wollen.  Wohin
  die Signale dann geleitet werden, ist Sache desjenigen, der den
  Treiber verwenden wird.
  
  Die beschriebene große Flexibilität gab den Ausschlag für eine
  Entscheidung zugunsten eines solchen Ansatzes.  Informationen über
  QT finden sich unter \cite{mwtt}.  Der einzige Nachteil der
  beschriebenen Lösung ist die Abhängigkeit von QT, was bei der
  Nutzung von QT als GUI für den PDA aber kein großes Hindernis
  darstellt.

\end{description}

\subsection{Zugriff der Treiber auf den CANBus}
Für den Zugriff auf den CANBus kann man ebenfalls die sehr mächtigen
Strukturen von QTOPIA nutzen.  In einem solchen Fall sendet das
Framework ein Signal, daß eine neue Nachricht vorliegt.  Über einen
Verteilermechanismus würde die Nachricht dann als Signal an einen
Slot des entsprechenden Treibers gesendet.

Im Läufer wird ein solcher Ansatz allerdings nicht verfolgt.  Statt dessen
erben alle Treiber von einer gemeinsamen Basisklasse, die die
Funktionalität des Sendens und Empfangens von Nachrichten zur
Verfügung stellt.  Das Empfangen ist dabei eine abstrakte virtuelle
Methode, die von jedem Treiber einzeln implementiert werden muß.
Hierzu haben die folgenden beiden Überlegungen geführt:

Zum einen den Teil der Bibliothek, der nicht direkt mit der GUI
zusammenhängt, möglichst portabel zu gestalten.  Das bedeutet auch,
daß man sich in diesem Bereich nicht von QT's Präprozessor abhängig
machen kann.

Zum anderen sind die anzubietenden Funktionalitäten in dem Teil des
Frameworks wesentlich übersichtlicher und auch schon im Laufe der
vorliegenden Arbeit bekannt: Das Senden und Empfangen von Nachrichten.
Die genaue Kenntnis der anzubietenden Funktionen nicht zu nutzen würde
unnötige Komplexität im Programm hervorrufen und die Bibliothek nur
unnötig vergrößern.

\subsection{Implementierungsdetails}
%Abbildung \ref{mw_uml} zeigt ein UML der entstandenen Bibliothek.
Auf Details zur Implementierung soll an dieser Stelle unter Hinweis
auf die im Anhang vorhandene API\footnote{API: Application Programming
  Interface}-Referenz verzichtet werden.

%UPDATEN
%\begin{figure}
%  \center \includegraphics[width=15.0cm]{mw/bilder/uml.eps}
%  \caption{UML der Klassenbibliothek}
%  \label{mw_uml}
%\end{figure}


%------------------------------------------------------------
\newpage
\section{Entstandene Software: DebugTreiber}

\subsection{Zweck des Tools}
Im Rahmen der Gespräche mit den ebenfalls am Projekt Läufer
beteiligten Maschinenbau-Studenten kam immer mehr zum Vorschein, daß
für die Entwicklung der mechatronischen Teile noch zusätzliche
Werkzeuge benötigt werden.  So ist es für eine zügige Entwicklung von
Komponenten nicht vertretbar, die Hardware parallel zum Treiber
entwickeln zu müssen.

Ein Entwickler z.B. eines Blinkers sollte die Möglichkeit erhalten,
seine Hardware zu testen, ohne tatsächlich schon den Treiber dazu
entwickelt zu haben. Der Entwickler weiß, welche ID\footnote{Diese
  jeder Komponente eindeutig zugeordnete Nummer muß allerdings für
  jedes mechatronische Gesamtsystem zentral vergeben werden, da ein
  globaler Addressraum, wie ihn z.B. Ethernet bietet, nicht zur
  verfügung steht.}sein Gerät hat und welche Operationen es versteht.
Folglich kann er die korrekte Funktionsweise durch manuelle Eingaben
und Beobachten der Reaktion seines Gerätes überprüfen. Beobachten kann
er entweder Änderungen am Gerät selber (z.B.: Lampe blinkt) oder aber
Rückmeldungen des Gerätes über den CAN-Bus.  Um den
Hardware-Entwicklern die Arbeit zu erleichtern, ermöglicht der
DebugTreiber nun genau das: Manuelles Senden und Empfangen von
Nachrichten an ein bzw. von einem bestimmten Gerät.

Da wir bei der Kommunikation zwischen Gerät und Treiber (siehe
\ref{mw_com}) ein hinreichend generisches Verfahren einsetzen, war es
leicht möglich, ein Programm zu entwickeln, das einen solchen
,,Handbetrieb'' eines Gerätes ermöglicht.

\subsection{Funktionalitätsübersicht}

\subsubsection{Senden}
Abbildung \ref{mw_screen_senden} zeigt die GUI zum Senden einer
Message an ein Gerät am CAN-Bus.  Wie in \ref{mw_com} beschrieben setzt
sich das Protokoll aus Operationen und eventuellen Parametern
zusammen.

Die Messages kann man hier (numerisch) zusammenstellen, um dem unter
,,Setup'' eingestellten Gerät eine Message zu senden.  Die GUI sollte
weitgehend selbsterklärend sein.  Sie verhindert, daß man Parameter
eingibt, die nicht gesendet werden, indem man vorher auswählen muß,
wieviele Parameter es denn werden sollen.  Einstellen kann dies ein
Benutzer mit dem Eingabefeld ,,Anzahl Datenbytes''.

Ein solches Tool kann (und will) allerdings nicht verhindern, daß
einem Gerät Befehle gesendet werden, die es nicht verstehen kann.  Der
Entwickler kann und will das selbst überprüfen, um auch das Verhalten
seines Systems bei falschen Eingabedaten zu testen.

\begin{figure}
  \center \includegraphics[width=5.0cm]{mw/bilder/GUI_senden.eps}
  \caption{Screenshot Senden}
  \label{mw_screen_senden}
\end{figure}


\subsubsection{Empfangen}
Abbildung \ref{mw_screen_empfangen} zeigt die GUI zum Empfangen von
Messages vom CAN-Bus.  Das Tool speichert eingehende Messages, die
unter der im ,,Setup'' eingestellten ID eintreffen.

Mit dem Feld ,,Übertragung'' kann man auswählen, welche der
gespeicherten Messages man betrachten möchte.  Dieses Feld zeigt
standardmäßig immer die Nummer der letzten empfangenen Message an.

Der Wechsel kann jedoch recht häufig sehr schnell von statten gehen.
Aus diesem Grund ist es möglich, den Prozeß zu pausieren.  Die Pause
kann der Benutzer mittels des Kontrollfeldes ,,Pause'' auslösen.
Einkommende Nachrichten werden bei aktivierter Pause weiterhin im
Hintergrund archiviert.

\begin{figure}
  \center \includegraphics[width=5.0cm]{mw/bilder/GUI_empfangen.eps}
  \caption{Screenshot Empfangen}
  \label{mw_screen_empfangen}
\end{figure}

\subsubsection{Setup}
Abbildung \ref{mw_screen_setup} zeigt die GUI zum Einrichten des
Debug-Tools.  Hier kann man die gewünschte ID des Gerätes einstellen,
für das sich das Tool als Treiber registriert.  Alternativ kann man
hier auswählen, einen sogenannten ,,Broadcast'' zu erstellen, der dann
an alle Busteilnehmer gesendet wird.

\begin{figure}
  \center \includegraphics[width=7.0cm]{mw/bilder/GUI_setup.eps}
  \caption{Screenshot Setup}
  \label{mw_screen_setup}
\end{figure}


\newpage
\section{Fazit}
Im Rahmen dieses Teilbereichs der Mechatronik-Entwicklung für das
Projekt Läufer wurde der Rahmen für das Fahrerinformationssystem des
Läufers entworfen und implementiert.  Der Rahmen wird dann von den
Maschinenbauern mit ihrer spezifischen Fachkenntnis ausgefüllt
werden.

Daß das Framework hinreichend Leistungsfähig ist, bewies die zügige
Entwicklung der Demo für die Cebit 2002, bei der der Läufer und seine
Mechatronik ausgestellt wurde.  Abbildung \ref{mw_cebit_gui} zeigt die
hierzu entwickelte GUI.  Auch bei dieser Entwicklung hat sich die Wahl
von Linux als PDA-System bewährt, da umfangreicher Support seitens der
Entwickler auf den entsprechenden Mailinglisten gegeben wurde, ohne
den eine solch schnelle Entwicklung sicher nicht möglich gewesen wäre.

\begin{figure}
  \center \includegraphics[width=7.0cm]{mw/bilder/Menu.eps}
  \caption{Der Compaq IPAQ mit der Läufer-Software für die Cebit 2002}
  \label{mw_cebit_gui} 
\end{figure}





%%% Local Variables:
%%% mode: latex 
%%% TeX-master: "master"
%%% End:

